<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>dracodemy.vercel.app</title>
        <link>dracodemy.vercel.app</link>
        <description>Welcome to Dracodemy! A website to learn programming efficiently</description>
        <lastBuildDate>Sun, 21 Jan 2024 04:08:51 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <language>en</language>
        <atom:link href="dracodemy.vercel.app/rss.xml" rel="self" type="application/rss+xml"/>
        <item>
            <title><![CDATA[1 - Fundamentals of Python - Python]]></title>
            <link>https://dracodemy.vercel.app/posts/1---fundamentals-of-python---python</link>
            <guid>https://dracodemy.vercel.app/posts/1---fundamentals-of-python---python</guid>
            <pubDate>Thu, 28 Dec 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[
## Introduction to Python

- Python is a scripting language that is used for creating smart and advance scripting language.
- It was developed by Guido van Rossum in 1991.
- It is high level programming language which is used by millions of people to perform task such as automating anything or to perform complex math operations.
- Python has very easy and simpler syntax compared to any other programming language which makes it beginner friendly.
- Python is interpreted programming language which means it’ll check and go through each and every line in code.
- It is independent programming language which means the code written on any machine can work on any machine just by installing required modules.

## Python Application

- Python can be used to create server side websites
- Python can be used to create software in computer system.
- It can be very efficient for creating databases.
- It is also used for advance tasks such as machine learning or artificial intelligence.
- It is used to fetch live data from the web and plot graphs based on the data in real time.
- we can create a whole new programming language on top of python.

## Basic Structure of python program

- basic structure of python program looks like this,

```python
import random

def generate_random_num():
  random_num = random.randint()
  print(random_num)

generate_random_num()

# This python program will generate random number and print in outptu
```

- Import Libraries:
  - Using import method we can import external functions or modules in our program.
- functions:

```python
def function_name():
  # code
```

- We can create user defined function with `def` keyword and use them where ever we like to
- Comments

```python
# This is comment in python code
```

- Comments are just pseudo code which is ignored by the compiler.
- I/O operations

```python
name = input("enter your name: ")
print("Hello, ", name)
```

- I/O means Input/output operations
- we can take input from user using `input()` function.
- we can give output to our console or screen using `print()` function.

## Keywords and identifiers

- Keywords:
  - Keywords are basically reserved words by programming language.
  - This words cannot be used to name any object or any component is program as they are reserved by programming language.
  - for example here are few keywords in python language
    - def
    - int
    - float
    - True
    - False
    - print
    - input
    - return
  - etc.
  - we cannot use this names for naming variables or function or anything.
- Identifiers:

  - Identifiers are basically words that identity any object in program.
  - we can name any variable or function to identify them throughout program and these are called identifiers.
  - for example,

  ```python
  name = "Preet"
  age = 17
  ```

  - Here in this program the `name` and `age` is called identifier because it identifies the value of the variable.
  - Identifiers cannot be same as keywords.

## Data Types and Variables

- Data Types:

  - Data types is basically type of data in our program.
  - These types are automatically defined by python as the python is interpreted programming language.
  - we don’t need to define the type of data we store separately.

```python
int age = 17 ❌
age = 17 ✅
```

- There are multiple data types in python,

  - Integer = 1, 2, 3, 4…
  - Float = 1.3, 5.3, 6.9…
  - String = “Hello world!”
  - Char = “H”, “E”
  - Boolean = True, False

- Variables:

  - Variables are basically containers that are used to store some data in our memory.
  - Think of variables as jar. we can store any item in jar so we can in variables.
  - we name an variable and assign some values to that variable.
  - we use identifiers to name any variables.
  - variable names cannot be same as keywords.
  - example:

```python
name = "Preet Suthar"

# here the `name` is identifier
  # for variable which can value of "Preet Suthar".
# now we can access the value of variable `name`,
  # using the identifier.

print(name) # output: Preet Suthar
```

## Type Casting

- Type casting is method of converting data type of one variable to another.
- Type casting is also known as type conversion.
- Type casting has two types,
  - Implicit Casting
  - Explicit Casting
- Here are the function used for type casting,
  - `int()`:
    - Used to convert any other type of data to integer.
    - `int(”12”) --> 12`
  - `float()`
    - Used to convert any integer type of data to float.
    - `float(10) --> 10.00`
  - `str()`
    - Used to convert any other type of data to string.
    - `str(10) --> "10"`
- Input/output function

  - Input:

    - we use `input()` function to take data as input from the user via keyboard.
    - we can take any sort of data for our variables to store or input any array or anything.
    - and we can directly store this input data into a variable.
    - Syntax:
      - `input()`
    - Example:

```python
name = input("Enter your name: ")
print("Hello, ", name)

# output:
# Enter your name: Preet
# Hello, Preet
```

- Output:

  - we use `print()` function to provide any output to the console or screen in python programming language.
  - this output can be anything from someone’s name to value of variable which was taken from the user.
  - Syntax:
    - `print(data_to_print)`
  - Example:

```python
name = "Preet Suthar"

# printing number
print(1)
# output: 1

#printing string
print("Hello world!")
# output: Hello world!

# printing data from the variable
print(name)
# output: Preet Suthar
```

## Operators

- Operators in python are used to perform operations on variables and values.
- There are multiple types of operators in python,
  - Arithmetic Operators:
    - These are basic operators which are used to perform mathematical operations.
    - `+`
      - Addition
      - `x + y`
    - `-`
      - Subtraction
      - `x - y`
    - `/`
      - Division
      - `x / y`
    - `%`
      - Modulus
      - `x % y`
    - `*`
      - Multiplication
      - `x * y`
    - `**`
      - Exponentiation
      - `x ** y`
  - Assignment Operators:
    - Assignment operators are used to assign values to variables.
    - Here are some of them
    - `=`
      - used to assign values to variable.
      - `x = 10`
    - `+=`
      - to make addition in existing value.
      - `x+=1 --> x = x + 1`
    - `-=`
      - to make subtraction in existing value.
      - `x -= 1 --> x = x - 1`
    - `*=`
      - to make multiplication in existing value.
      - `x *= 1 --> x = x * 3`
    - `/=`
      - same as above but for division
    - `**=`
      - same as above but for exponentiation.
    - `%=`
      - same as above but for modulus.
  - Comparison Operators:
    - Comparison operators are used to compare values
    - `==`
      - Equal to (check if both of the values are same)
    - `!=`
      - Not Equal to.
    - `>`
      - Greater than
    - `<`
      - Less than
    - `>=`
      - Greater than or equal
    - `<=`
      - Less than or equal
  - Logical Operators:
    - Logical operators are used to combine conditional statements.
    - `and`
      - If all of the condition are True.
      - `x < 4 and x > 6`
    - `or`
      - if at least one condition is True
      - `x < 4 or x > 10`
  - Membership Operators:
    - Membership operators are used to check if specific sequence is present in an object.
    - `in`
      - Check if sequence is present in the object
      - `x in y`
    - `not in`
      - Check if sequence is not present in the object
      - `x not in y`
]]></description>
        </item>
        <item>
            <title><![CDATA[1 - Introduction to Database System and SQL commands | RDBMS]]></title>
            <link>https://dracodemy.vercel.app/posts/1---introduction-to-database-system-and-sql-commands-rdbms</link>
            <guid>https://dracodemy.vercel.app/posts/1---introduction-to-database-system-and-sql-commands-rdbms</guid>
            <pubDate>Tue, 09 Jan 2024 00:00:00 GMT</pubDate>
            <description><![CDATA[
## Concepts and Definitions: Database and database systems and database environment

- Database -
  - Database is organized collection of data or information. It allows efficient storage, retrieval, updating and searching of large amount of information.
- Database System -
  - The database system refers to the database, DBMS software or applications that interactive with the data.
- DBMS (Database Management System) -
  - This refers to software designed to define, create, alter, update, view, delete or perform other more queries on database.
- Database Environment -
  - It refers to comprehensive architecture and ecosystem supporting the database in organization. It includes, DBMS software, database servers, hardware, Application, User Interface or anything related database.

## Data, Information, Data Item or Fields, Records, Files, Metadata, Data dictionary and it’s components

- Data -
  - Collection of raw facts containing key and value.
- Information -
  - Information is what we get as output when we process bunch of data.
- Data Item/field -
  - Data item/field refers to specific single piece of information in a table.
- Records -
  - Collection of multiple fields or related data item is called records.
- Files -
  - Collection of multiple records is called File.
- Metadata -
  - Metadata refers to data about data, It describes the structure, data type, formats, etc.
- Data Dictionary and It’s components -
  - Data Dictionary is collections of metadata info containing definitions and descriptions related all data items.
  - Components of Data Dictionary -
    - Field Name - Name assigned to data element.
    - Description - Description explaining the element.
    - Data Type - Type of data like int, char, varchar
    - Format - Field validating
    - Who created it and when
    - etc.

## Schemas, Sub-schemas, and Instances

- Schemas -
  - Schema is basically logical configuration or structure of database. It defines what data will be stored in which field. For example, Student schema might have fields like ID, Name, Class, etc.
- Sub-schemas -
  - Sub-schema is a subset of schema that has same elements as the schema. It’s set of data elements that belongs to table.
  - For example a table can represent “India”, in that table we have “Phone Code” In that we have subschema for each state like which state represent which code.
- Instance -
  - Instance is the data stored in database at a particular moment of time.
  - It takes note of occurrences in database.

## Data Types

- In RDBMS we have various data types such as,
  - INT
    - INT data type is used to represent numeric data types.
  - CHAR
    - CHAR data type used to represent single character data.
  - FLOAT
    - FLOAT data type is used to represent point values data.
  - VARCHAR
    - VARCHAR data type is used to represent string data.
    - `VARCHAR(size_of_string)`
  - BOOLEAN
    - BOOLEAN data type is used to represent TRUE or FALSE value.
  - DATETIME
    - DATETIME, DATE, TIME, TIMESTAMP these data types are used to represent the date or time value.
  - BINARY/BLOB
    - BINARY large objects and byte arrays for storing files, images etc.
  - etc.

## Database Language commands: Data Definition Language (DDL): CREATE, ALTER, TRUNCATE, DROP

- DDL commands in RDBMS is used to define and manage structure of database like, tables, indexes, etc.
- CREATE -
  - CREATE command is used to create new database, table or other objects.
  - Example -

```sql
  CREATE DATABASE students;
```

- ALTER -
  - ALTER command is used to modify or update tables r object in database.
  - Example -

```sql
ALTER TABLE students ADD email VARCHAR(100);
```

- TRUNCATE -
  - TRUNCATE command is used to clear entire data from the database table without deleting rows or columns.
  - Example -

```sql
TRUCATE TABLE students;
```

- DROP -
  - DROP command is used to drop means delete entire objects like tables or entire database.
  - Example -

```sql
DROP DATABASE students;
```

## Database Language: Data Manipulation Language (DML): INSERT, SELECT, UPDATE, DELETE

- DML Commands in RDBMS are used to manipulate the data inside the database or tables by running queries.
- INSERT -
  - INSERT command is used to insert new data in table of database.
  - Example -

```sql
INSERT INTO students(name, fees, email)
VALUES ('John', 5000, 'john@example.com');
```

- SELECT -
  - SELECT command is used to select data from the table and print in console.
  - Example -

```sql
SELECT * FROM student_data;
-- using * we can select entire table data.
```

- UPDATE -
  - UPDATE command is used to update existing data or modify data in specific columns of table.
  - Example -

```sql
UPDATE students
SET fees = 2600
WHERE id = 2;
```

- DELETE -
  - DELETE command is used to delete specific record from the table based on given conditions.
  - Example -

```sql
DELETE FROM students
WhERE id = 3;
```
]]></description>
        </item>
        <item>
            <title><![CDATA[2 - Control Flow Structure - Python]]></title>
            <link>https://dracodemy.vercel.app/posts/2---control-flow-structure---python</link>
            <guid>https://dracodemy.vercel.app/posts/2---control-flow-structure---python</guid>
            <pubDate>Fri, 29 Dec 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[
## Introduction to Control Structures

- Control structure is part of programming language where it allows us to control the flow of code execution in python.
- this control structures can add conditions or repetition or iterations.
- here are types of control structures,

### Conditional statements

- conditional statements allows us to control the flow of code execution by providing specific conditions to program
- `if`

  - `If` is used to check any specific condition matches or not, if yes then it’ll return true and execute the code if not then it’ll return false and execute the code given for false condition.
  - example:

  ```python
  age = 18
  if age < 18: # when condition is true
    print("User can drive!")
  else: # when condition becomes false
    print("User cannot drive!")
  ```

- `elif`

  - `elif` is used to add extra condition on top of `if` condition for even more specific control on execution.
  - example:

  ```python
  age = 18

  if age <= 0: # first `if` condition to check if we got valid age in input
    print("invaid user!")
  elif age < 18: # elif condition `extra condition` to check if age is less than 18
    print("user can drive!")
  else:
    print("user cannot drive!")
  ```

- `else`

  - else is default code execution when none of the given condition matches.
  - it’ll execute else when none of the given condition is fulfilled.
  - example:

  ```python
  name = "John"

  if name == "Doe":
    print("user found!")
  else: # It'll execute else because the `if` condition isn't matched
    print("user not found!")
  ```

### Loops

- Loops in python are used to iterate over existing object or to print some of output for specific amount of numbers.
- Loops can be very useful when we want to print same and same thing over and over again until our condition is matched.
- Loops are also useful when we want to print some series like series of numbers or series of factorials etc.
- There are two types of loops,

  - For loop

    - `For loop` in python is used for more like sequential traversal over any object.
    - for example traversing a list or string or array.
    - using for loop we can traverse and process every single element in array or object or every single alphabet in string.
    - syntax:

      ```python
      for iterate_var in object:
       print(iterate_var)
      ```

    - example:

      ```python
      name = "John"

      for x in name:
       print(x)

      # output:
      # J
      # o
      # h
      # n
      ```

  - While loop

    - While loop in python are basically used to repeat block of code until specific condition matches which is given inside while loop.
    - whenever we add while loop we provide condition inside that loop and until that condition matches the code inside the loop is repeated continuously.
    - syntax:

      ```python
      while (condition):
       # code
      ```

    - example:

      ```python
      count = 0

      while (count < 3): # we provide a condition in while loop
       count = count + 1 # we increment the value of `count` everytime loop is working
       print("Hello!!") # we print the output until the count becomes 3

      # output:
      # Hello!!
      # Hello!!
      # Hello!!
      ```

## If, If-else statements

- Conditional statements

  - conditional statements allows us to control the flow of code execution by providing specific conditions to program
  - `if`

    - `If` is used to check any specific condition matches or not, if yes then it’ll return true and execute the code if not then it’ll return false and execute the code given for false condition.
    - example:

      ```python
      age = 18
      if age < 18: # when condition is true
       print("User can drive!")
      else: # when condition becomes false
       print("User cannot drive!")
      ```

  - `elif`

    - `elif` is used to add extra condition on top of `if` condition for even more specific control on execution.
    - example:

      ```python
      age = 18

      if age <= 0: # first `if` condition to check if we got valid age in input
       print("invaid user!")
      elif age < 18: # elif condition `extra condition` to check if age is less than 18
       print("user can drive!")
      else:
       print("user cannot drive!")
      ```

  - `else`

    - else is default code execution when none of the given condition matches.
    - it’ll execute else when none of the given condition is fulfilled.
    - example:

    ```python
    name = "John"

    if name == "Doe":
     print("user found!")
    else: # It'll execute else because the `if` condition isn't matched
     print("user not found!")
    ```

## Nested If-else

- Nested if else in python are used to create method to check condition twice or check multiple condition inside a condition that is true.
- for example, XYZ condition is true, now i want to check if XYZ condition is true then and then check if ABC condition is true, if ABC condition is true then and then check MNO condition is true and goes on.
- it is useful when we have multiple set of conditions to be checked if one condition becomes true.
- syntax:

  ```python
   if condition:
     if condition:
      # code
     else:
      # code
   else:
     # code
  ```

- example:

  ```python
  number = 9

  if (n%5==0):
    if (n%3==0):
      print(f"The number {n} is dividable by both 5 and 3.")
    else:
      print(f"The number {n} is only dividable by 5 not 3.")
  else:
    if(n%3==0):
      print(f"The number {n} is only dividable by 3 not 5")
    else:
      print(f"The number {n} is neither dividable by 3 nor 5")
  ```

## Switch statement

- Switch statement is core mechanism in python that checks the values stored in variable and execute the code based on case statements provided.
- switch statement also known as switch is case is replacement for nested if else in python if you’re working with single variable condition checking.
- syntax:

  ```python
  match term:
   case patternOne:
     # code 1
   case patternTwo:
     # code 2
   case patternThree:
     # code 3
   case patternFour:
     # code 4
   case patternFive:
     # code 5
   case _:
     # default code
  ```

- example:

```python
lang = input("Enter your programming language (only one): ")

match lang:
 case "javascript":
  print("You can become web developer.")
 case "python":
  print("You can become data scientist.")
 case "php":
  print("You can become backend developer.")
 case _:
  print("Language doesn't matter, Problem solving skills matters!")
```

## For loops

- For loop

  - `For loop` in python is used for more like sequential traversal over any object.
  - for example traversing a list or string or array.
  - using for loop we can traverse and process every single element in array or object or every single alphabet in string.
  - syntax:

    ```python
    for iterate_var in object:
     print(iterate_var)
    ```

  - example:

    ```python
    name = "John"

    for x in name:
     print(x)

    # output:
    # J
    # o
    # h
    # n
    ```

## While loops

- While loop

  - While loop in python are basically used to repeat block of code until specific condition matches which is given inside while loop.
  - whenever we add while loop we provide condition inside that loop and until that condition matches the code inside the loop is repeated continuously.
  - syntax:

    ```python
    while (condition):
     # code
    ```

  - example:

    ```python
    count = 0

    while (count < 3): # we provide a condition in while loop
     count = count + 1 # we increment the value of `count` everytime loop is working
     print(f"Counter: {count}") # we print the output until the count becomes 3

    # output:
    # Counter: 1
    # Counter: 2
    # Counter: 3
    ```

## Nested loops

- nested loop is a loop inside a loop.
- in nested loop the `inner loop` will be executed one time each iteration of the `outer loop`.
- syntax:

  ```python
  for x in x:
   for y in y:
    for z in z:
     print(x, y, z)
  ```

- example:

  ```python
  colors = ["red", "yellow", "green"]
  fruits = ["apple", "banana", "apple"

  for x in colors:
   for y in fruits:
    print (x, y)

  # output:
  # red apple
  # yellow banana
  # green apple
  ```

## Break, Continue and pass statement

- Break

  - break statement is used in python to instantly terminate the loop when break statement is encountered.
  - it’ll instantly stop the loop when break statement is passed in loop.
  - syntax:

  ```python
  break
  ```

  - example:

    ```python
    while (count = 5):
     count = count + 1
     if count == 3:
      print("Counter has reached 3, now stopping the loop")
      break
     else:
      print(count)
    ```

    - Here in this example we have provided a counter while loop and in that loop we provided condition that if count becomes `3` we break the loop and if not then we continue printing.
    - what it’ll do is whenever the count value becomes `3` it’ll encounter break statement and instantly terminate the loop.

- Continue

  - continue statement is used to continue any loop when specific condition is matched.
  - it’ll continue to iterate the loop when it'll encounter `continue` statement.
  - using continue isn’t very required for small projects, it’s optional.
  - syntax:

    ```python
    continue
    ```

  - example:

    ```python
    while (count = 5):
     count = count + 1
     if count == 3:
      print("Counter has reached 3, now continuing the loop")
      continue
     elif count == 5:
      print("break encountered;")
      break
    ```

    - here in this example we have created same counter loop but if the counter reaches the `3` it’ll continue the counting instead of breaking the loop on count `3`
    - and when it’ll reach `5` we’ll break the loop.

- Pass

  - Pass statement is used to skip any specific iteration in code execution.
  - it’ll skip the iteration where we passed the `pass` statement.
  - syntax:

  ```python
  pass
  ```

  - example:

    ```python
    while (count = 5):
     count = count + 1
     if count == 3:
      print("passing the count 3")
      pass
     elif count == 5:
      print("break encountered;")
      break
    ```

    - here in this same counter example we have passes condition where if count reaches count `3` it’ll pass that iteration.
    - which means if `count == 3` it’ll basically skip the `count 3` and won’t print `3` instead it’ll directly print `4` after `2`.
]]></description>
        </item>
        <item>
            <title><![CDATA[2 - SQL In built functions and Joins | RDBMS]]></title>
            <link>https://dracodemy.vercel.app/posts/2---sql-in-built-functions-and-joins-rdbms</link>
            <guid>https://dracodemy.vercel.app/posts/2---sql-in-built-functions-and-joins-rdbms</guid>
            <pubDate>Wed, 10 Jan 2024 00:00:00 GMT</pubDate>
            <description><![CDATA[
## Operators Arithmetic, Comparison, Logical, SQL functions-

- Single Row Function -
  - Single row functions return single row for every row of queried table or view.
  - These functions can appear in select lists, WHERE clauses, START WITH clauses, CONNECT BY clauses and HAVING clauses.
- Date Functions -

  - ADD_MONTHS() -

    - It adds or subtracts months from a date.

    ```sql
    SELECT ADD_MONTHS(DATE '2023-01-31', 5) FROM dual;
    -- Adds 5 months to the date '2023-01-31'
    ```

  - MONTHS_BETWEEN() -

    - Get total number of months between given date.

    ```sql
    SELECT MONTHS_BETWEEN(DATE '2023-07-30', DATE '2022-02-1') FROM dual;
    -- returns total number of months between two dates.
    ```

  - ROUND() -

    - Rounds a date to specified unit.

    ```sql
    SELECT ROUND(DATE '2023-01-02', 'MONTH') FROM dual;
    -- Rounds the date to nearest month.
    ```

  - TRUNC() -

    - Truncates the date to specified unit.

    ```sql
    SELECT TRUNC(DATE '2023-01-19', 'MONTH') FROM dual;
    -- truncates the date to first day of month
    ```

- Numeric Functions -

  - ABS() -

    - Returns absolute value.

    ```sql
    SELECT ABS(-15) FROM dual;
    ```

  - POWER() -

    - Returns exponential of passed numbers.

    ```sql
    SELECT POWER(3, 3) FROM dual;
    ```

  - MOD() -

    - Returns modulus of passed numbers.

    ```sql
    SELECT MOD(10, 5) FROM dual;
    ```

  - ROUND() -

    - Rounds up the value to nearest number.

    ```sql
    SELECT ROUND(3.2) FROM dual;
    ```

  - TRUNC() -

    - Truncates to previous integer decimal or given unit.

    ```sql
    SELECT TRUNC(111.11, 1) FROM dual;
    -- will truncate last 1 decimal so output will be '111.1'
    ```

  - SQRT() -

    - Returns square root of passed number.

    ```sql
    SELECT SQRT(25) FROM dual;
    ```

  - RAND() -

    - Returns random value from between 0 to 1.

    ```sql
    SELECT RDBMS_RANDOM.VALUE() from dual;
    ```

- Character Functions -

  - INITCAP() -

    - Capitalize first letter of words.

    ```sql
    SELECT INITCAP('hello world') FROM dual;
    ```

  - LOWER() -

    - Converts text into lowercase()

    ```sql
    SELECT LOWER('HELLO WORLD') FROM dual;
    ```

  - UPPER() -

    - Converts text into uppercase()

    ```sql
    SELECT UPPER('hello world') FROM dual;
    ```

  - LTRIM() -

    - Trims extra and unnecessary spaces from the beginning of the sentence.

    ```sql
    SELECT LTRIM('          hello world') FROM dual;
    ```

  - RTRIM() -

    - Trims extra and unnecessary space at the end of the sentence.

    ```sql
    SELECT RTRIM('hello world          ') FROM dual;
    ```

  - REPLACE() -

    - Replaces text with some other text.

    ```sql
    SELECT REPLACE('Hello world', 'lo', 'p') FROM dual;
    -- will replace `lo` with `p` so output will be 'Help world'.
    ```

  - SUBSTR() -

    - Extracts the substring from the string.

    ```sql
    SELECT SUBSTR('Hello world', 3) FROM dual;
    -- Extracts the string from the index 3.
    ```

  - INSTR() -

    - Used to get position of the sub string in string.

    ```sql
    SELECT INSTR('Hello world', 'o') FROM dual;
    -- will return the first 'o' in the string.
    ```

- Conversion Functions -

  - TO_CHAR() -

    - Converts number/date to string.

    ```sql
    SELECT TO_CHAR(69, "99") FROM dual;
    ```

  - TO_DATE() -

    - Converts a string to date.

    ```sql
    SELECT TO_DATE('January 15, 2023', 'Month dd, yyyy') FROM dual;
    ```

  - TO_NUMBER() -

    - Converts a string to number.

    ```sql
    SELECT TO_NUMBER('23', '99') FROM dual;
    ```

## Group by, Having and Order by clause

- GROUP BY -

  - It is used to group rows that has same value into summary rows.
  - It can be used with functions like AVG(), SUM(), COUNT() to calculate the summaries for each group.
  - It groups rows based on one or more columns specified after GROUP BY keyword.s

  ```sql
  SELECT department, AVG(salary)
  FROM employees
  GROUP BY department;
  ```

  - Example -

  ```sql
  SELECT NAME, SUM(SALARY) FROM emp
  GROUP BY NAME;
  ```

  ![Untitled](https://i.imgur.com/lue22xk.png)

  - In above example you can see that using GROUP BY we grouped two different columns and fetched view of both columns together.

- HAVING -

  - This is used to filter groups after GROUP BY clause grouped two rows/columns together.
  - Allows filtering smallest data based on given conditions.
  - Conditions can use smallest data and columns used in GROUP BY.
  - It is applied after using GROUP BY clause.
  - GROUP BY > HAVING

  ```sql
  SELECT department, SUM(salary)
  FROM employees
  GROUP BY department
  HAVING SUM(salary) > 100000;
  ```

  - Example -

  ```sql
  SELECT Department, sum(Salary) as Salary
  FROM employee
  GROUP BY department
  HAVING SUM(Salary) >= 50000;
  ```

  ![Untitled](https://i.imgur.com/bBl7WA3.png)

  - In above example as you can see we’re grouping the departments where salary is greater than 50,000 using HAVING clause.

- ORDER BY -

  - This is used to sort the output data in ascending or descending order.
  - It sorts rows based on one or more columns specified after ORDER BY clause.
  - ASC sorts data in ascending and DESC sorts data in descending order.
  - This clause is applied at last after all other clauses like GROUP BY, HAVING etc.
    - Means GROUP BY > HAVING > ORDER BY

  ```sql
  SELECT year, COUNT(*)
  FROM transactions
  GROUP BY year
  ORDER BY year DESC;
  ```

  - Example -

  ```sql
  SELECT * FROM students ORDER BY ROLL_NO DESC;
  ```

  ![Untitled](https://i.imgur.com/uBLYLHt.png)

  - In above example we have ordered the students data in Descending order which means greater → less.

## Joins: Simple (Cross join), Equi-join & Non-Equi-join (Inner join), Self-Joins, Outer-joins

- CROSS JOIN -

  - The CROSS JOIN returns all records from both of the tables.
  - For example, if there are three records in table 1 and three records in table 2, after performing CROSS JOIN it’ll return total of 6 records.
  - Output of Cross Join is similar to Cartesian product so this operation is also referred to Cartesian Product.
  - As this join operation is simplest among all joins that’s why it’s also called **Simple Join**.

    ![Untitled](https://i.imgur.com/5yG2alh.png)

  - Syntax -

  ```sql
  SELECT * FROM table1 CROSS JOIN table2
  ```

- INNER JOIN -

  - The INNER JOIN will return the matching records from the both tables.
  - Inner join is most common join among all.
  - If both the Joins are compared for equality then the operation will be called **Equi-Join.**
  - And opposite if both the joins are compared for non-equality then the operation will be called **Non-Equi join.**

    ![Untitled](https://i.imgur.com/mMl5eR3.png)

  - Syntax -

  ```sql
  SELECT * FROM table1 INNER JOIN table2
  ON table1.column_name = table2.column_name
  ```

- SELF JOIN -

  - When we want to join one table with itself then we have to use SELF JOIN.
  - In SELF JOIN we can give single table aliases and join that table with itself.
  - Self-Join is similar to inner join, except the table is joined with it self.
  - Each row in table is combined with every other row in the same table to produce a result.

    ![Untitled](https://i.imgur.com/KU7SJfS.png)

  - Syntax -

  ```sql
  SELECT * FROM table1 T1, table1 T2
  WHERE condition;
  ```

  - In above example we have gave alias (nickname) to table1 to connect it with itself.

- OUTER JOIN -

  - The OUTER JOIN in SQL has three types,

    - RIGHT JOIN-

      - The RIGHT OUTER JOIN returns all the records from the right table and the matching records from the left table.
      - If it don’t find any matching element in right table then it returns with NULL.

        ![Untitled](https://i.imgur.com/tTLHyYX.png)

      - Example -

        ```sql
        SELECT * FROM table1 RIGHT JOIN table2
        ON table1.column_name = table2.column_name;
        ```

    - LEFT JOIN -

      - The LEFT OUTER JOIN returns all the record from the left table and the matching records from the right table.
      - If it don’t find any matching element in right table then it returns with NULL.

        ![Untitled](https://i.imgur.com/EeDilot.png)

      - Example -

        ```sql
        SELECT * FROM table1 LEFT JOIN table2
        ON table1.column_name = table2.column_name;
        ```

    - FULL OUTER JOIN -

      - The FULL OUTER JOIN returns all the records when there is a match in left or right table records.
      - The FULL OUTER JOIN can potentially return very large set of data.

        ![Untitled](https://i.imgur.com/pl72NUa.png)

      - Example -

        ```sql
        SELECT * FROM table1 FULL OUTER JOIN table2
        ON table1.column_name = table2.column_name
        WHERE condition;
        ```

## Subqueries - Multiple, Correlated

- Multiple Subqueries -

  - It allows combining multiple subqueries using logical operators like AND, OR.
  - Each Sub query is typically enclosed in its own parentheses.
  - Outer query reference the main table and the result of sub queries.
  - Useful for applying multiple criteria from the same or different table.
  - Example -

  ```sql
  SELECT * FROM Employees as e
  WHERE e.salary > (SELECT AVG(salary) FROM Employees
  AND e.hire_date IN (SELECT hire_date FROM Employees WHERE name LIKE "A%");
  ```

- Co-related Queries -

  - Sub query reference to outer column.
  - Sub query is re-run for each row processed by the outer query.
  - It can perform comparisons, filtering based on outer query data.
  - Useful when subquery logic needs to utilize columns for each outer query row
  - Example -

  ```sql
  SELECT * FROM employees AS e1
  WHERE e1.salary > (SELECT AVG(salary) FROM employees e2
                     WHERE e2.department_id = e1.department_id);
  ```

## Implementation of Queries using SQL Set operators: Union, union all, Intersect, Minus

- Union

  - Union is used to combine the result of two selected statements.
  - It will remove the duplicated rows from the result obtained after performing UNION operation.
  - It useful to combine different results into one.

    ![Untitled](https://i.imgur.com/chrIPhq.png)

  ```sql
  SELECT column1 FROM table1
  UNION
  SELECT column1 FROM table1;
  ```

- Union All

  - Union All also combine results of multiple SELECT statements.
  - But it does not removes the duplicate rows from the result like UNION.
  - It keeps all the rows from all the SELECT statement, including duplicates.

    ![Untitled](https://i.imgur.com/OlvRWS3.png)

  ```sql
  SELECT column1 FROM table1
  UNION ALL
  SELECT column1 FROM table2;
  ```

- Intersect

  - Intersect returns only those rows which are common in between two select statements.
  - Similar to taking an intersection between sets.
  - It is very useful for finding common data in multiple tables.

    ![Untitled](https://i.imgur.com/bvWGCTC.png)

  ```sql
  SELECT column1 FROM table1
  INTERSECT
  SELECT column1 FROM table2;
  ```

- Minus

  - It returns the rows which are present in first query but absent in second query with no duplicates.
  - Subtracts common rows from the first result set.
  - It is Opposite to INTERSECT operation.

    ![Untitled](https://i.imgur.com/g8NOLqJ.png)

  ```sql
  SELECT column1 FROM table1
  MINUS
  SELECT column1 FROM table2;
  ```
]]></description>
        </item>
        <item>
            <title><![CDATA[3 - Database Integrity Constraints & Objects | RDBMS]]></title>
            <link>https://dracodemy.vercel.app/posts/3---database-integrity-constraints-objects-rdbms</link>
            <guid>https://dracodemy.vercel.app/posts/3---database-integrity-constraints-objects-rdbms</guid>
            <pubDate>Thu, 11 Jan 2024 00:00:00 GMT</pubDate>
            <description><![CDATA[
## Domain Integrity constraints: Not null, Check

- Not null -

  - Not null constraints allows us to add requirement to specific column that, the column cannot be null.
  - It ensures that the value is provided.
  - syntax -

  ```sql
  CREATE TABLE t1(
   name VARCHAR(50) NOT NULL;
  );
  ```

  - Using this constraint when trying to insert row or column that is null it’ll return error.

- Check -

  - Check constraints is used to limit value or range for a column that is placed.
  - If you define check constraint on a column it’ll allow only specified values to be inserted.
  - syntax -

  ```sql
  CREATE TABLE t1(
   age int,
   CHECK (age>=18)
  );
  ```

  - Here using check constraint will make sure that the inserting age is equal to 18 or above 18.

## Entity Integrity constraints: Unique, Primary key

- Unique -

  - Using unique constraint it allows to make sure that the values in columns is always unique.
  - A table can have multiple UNIQUE constraints in it.
  - It will guarantee for uniqueness in column or set of columns.
  - Syntax -

  ```sql
  UNIQUE;
  ```

  ```sql
  CREATE TABLE employee(
   id INT NOT NULL UNIQUE,
   name VARCHAR(50)
  );
  ```

- Primary key -

  - Primary key constraint allows us to make any specific column a primary key.
  - Using that column we can uniquely identify each record in a table.
  - Primary key must be UNIQUE.
  - primary key cannot be NULL.
  - Syntax -

  ```sql
  PRIMARY KEY;
  ```

  ```sql
  CREATE TABLE t1(
   id INT PRIMARY KEY NOT NULL,
   name VARCHAR(50);
  );
  ```

## Referential Integrity constraints: Foreign key, referenced key, on delete cascade

- Foreign key -
  - A foreign key is columns or set of columns which creates links between two tables and columns in SQL
  - It establishes connection between two tables.
  - The table with foreign key is called child table, and the table with primary key is called referenced table or parent table.
- Referenced key -
  - The referenced key or the target key is primary key of the table that the foreign key refers to.
  - The value in in foreign key must match the values in referenced key.
  - It is used to ensure data integrity in tables.
- On delete cascade -
  - On delete cascade is very important keyword to define while defining foreign keys.
  - The ON DELETE CASCADE is used when defining foreign key.
  - This is very important to maintain data integrity between tables.
  - ON DELETE CASCADE will automatically remove all the related foreign key records if main table (referenced table) record is deleted.
  - It prevents orphan records and keeps the data in sync.

## Views – Create, Alter, Drop views

- Views are basically virtual tables which is result of SQL queries.
- Views can contain columns and rows.
- To create views we can use `CREATE VIEW` keyword.
- Types of views-
  - Simple view
  - User defined view
  - Indexed view
- Advantages -
  - Takes very little space to store.
  - Simplifies data and shows in table manner.
  - It can represent consistent image of data and tables without changing structure of database.
- Disadvantages -
  - Cannot create views on temporary tables.
  - Cannot pass parameters to SQL server views.
  - Cannot execute any query if only READ MODE is enabled.
- Syntax -

  ```sql
  CREATE VIEW view_name AS
  SELECT column1, column2.....
  FROM table_name
  WHERE condition;
  ```

- Example -

  ```sql
  CREATE VIEW detailsView AS
  SELECT name, id
  FROM students
  WHERE id > 10;
  ```

  ```sql
  SELECT * FROM detailsView;
  ```

- Altering view -

  - We can change definition of a view using `ALTER VIEW` query.

  ```sql
  ALTER VIEW view_name AS
  SELECT column1, column2.....
  FROM table_name;
  ```

  - This allows changing or modifying view column or tables.

- Dropping view -

  - Dropping view means deleting a view.
  - To drop a view we can use `DROP VIEW` query in SQL.

  ```sql
  DROP VIEW view_name;
  ```

  - Drops the view definition while keeping the base table.

## Synonym: Create, Drop synonym

- Synonym -

  - Synonym is basically another name for our database object.
  - It provides alternative name for database objects like tables, views etc.
  - Syntax -

  ```sql
  CREATE SYNONYM synonym_name
  FOR object_name;
  ```

  - Here object_name can be table or view or anything.
  - It does not create different object but instead they are alias names mapping to other objects.
  - They allows simpler/alternate naming of objects.

- DROP Synonym -

  - To drop synonym we can use `DROP` statement.
  - It’ll delete the synonym.

  ```sql
  DROP SYNONYM synonym_name;
  ```

- CREATE Synonym -

  - A synonym is created using `CREATE` statement.

  ```sql
  CREATE SYNONYM synonym_name
  FOR object_name;
  ```

## Sequences: Create, alter, Drop sequences

- Sequence -
  - A sequence in SQL database is an object that is used to generate sequential set of integer numbers.
  - It will generate unique integer number in ascending or descending order.
  - We can define starting point and ending point or increment value when creating sequence.
  - These sequence can be used repeatedly in database.
- CREATE SEQUENCE -

  - We use `CREATE SEQUENCE` keywords to create a new sequence.

  ```sql
  CREATE SEQUENCE sequence_name
  START WITH 1
  INCREMENT BY 1;
  ```

  - Above example will generate series of number starting with 1 which will increment each integer by 1.

- ALTER SEQUENCE -

  - We can alter the sequence using `ALTER` keyword.

  ```sql
  ALTER SEQUENCE sequence_name
  START WITH 100
  INCREMENT BY 5;
  ```

- DROP SEQUENCE -

  - To remove or delete unused sequence we can `DROP` sequence.

  ```sql
  DROP SEQUENCE sequence_name;
  ```

## Index: Unique and composite – Create, Drop

- Indexes are very useful in database which is very efficient lookup method in table.
- It speeds up the process of data retrieval.
- It holds pointers which refers to data stored in database.
- They are similar to bookmarks in a book.
- It keeps track of all data.
- Create index -

```sql
CREATE INDEX index_name ON table_name;
```

- There are two types of indexes -

  - Unique index -

    - A unique index make sures that the data stored in index is unique across all rows.
    - It prevents duplicate entries.
    - It basically creates PRIMARY KEY and UNIQUE constraint in index.
    - syntax -

    ```sql
    CREATE UNIQUE INDEX index_name ON table_name;
    ```

  - Composite index -

    - Composite indexes can be created on multiple columns combined.
    - It speeds up queries using those columns together.

    ```sql
    CREATE INDEX index_name
    ON table_name(column1, column2);
    ```
]]></description>
        </item>
        <item>
            <title><![CDATA[3 - List, Tuples, Sets and Dictionaries - Python]]></title>
            <link>https://dracodemy.vercel.app/posts/3---list-tuples-sets-and-dictionaries---python</link>
            <guid>https://dracodemy.vercel.app/posts/3---list-tuples-sets-and-dictionaries---python</guid>
            <pubDate>Sat, 30 Dec 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[
## Lists and operations on Lists

- List

  - List in python is collection of multiple data with various data type.
  - It’s just like array but list can contain multiple type of data.
  - list can have strings, characters, numbers, float, etc.
  - list are dynamic array which means we don’t need to provide any length for our lists.
  - how to create list

    - list are stored in variable and to create a list the data are stored between `[]`
    - syntax

      ```python
      my_list = [1,3,4,5,]
      ```

      ```python
      my_list = ["hi", "hello", "hola!"]
      ```

  - list can consist multiple types of data which means list can be dynamic,

    ```python
    my_list = ["Hi", 23, 4.3, "H", True]
    ```

  - Characteristics of lists:
    - Lists are in order
    - elements can be accessed by index numbers
    - The lists are mutable
    - various types of element and data can be stored in list.
  - Operations on lists:

    - Concatenation

      - Concatenating multiple lists

      ```python
      list1 = [2,5,6]
      list2 = [3,5,2]

      list3 = list1 + list2
      print(list3)

      # output: [2,5,6,3,5,2]
      ```

    - Length

      - Measuring length of a list

      ```python
      list1 = [4,5,6,5,7,3]
      print(len(list1)

      # output: 6
      ```

    - Iteration

      - Iterating over entire list and processing each and every element.

      ```python
      list1 = [3,4,5]
      for x in list1:
       print(x)

      # output: 3 4 5
      ```

    - Membership

      - Check if any specific item or data is inside the list.

      ```python
      list1 = ["red", "yellow", "blue"]
      print("red" in list1)

      # output: True
      ```

## Tuples and operations on Tuples

- Tuples in python are used to store multiple items in a single variable.
- Tuple is collection which is ordered and unchangeable
- they are defined with `()` and stored in single variable
- syntax

  ```python
  my_tuple = ("apple", "banana", "cherry")
  print(my_tuple)
  ```

- Characteristics of tuples
  - Tuples are immutable data type which means their data cannot be changed after they are generated
  - Tuples allows duplicate data to be processed on.
  - Each element in tuple has a specific order that will never change because tuples are ordered sequence.
- Operations on tuples

  - Concatenation

    - Concatenating multiple tuples

    ```python
    tuple1 = (2,5,6)
    tuple2 = (3,5,2)

    tuple3 = tuple1 + tuple2
    print(tuple3)

    # output: (2,5,6,3,5,2)
    ```

  - Length

    - Measuring length of a tuple

    ```python
    tuple1 = (4,5,6,5,7,3)
    print(len(tuple1)

    # output: 6
    ```

  - Iteration

    - Iterating over entire tuple and processing each and every element.

    ```python
    tuple1 = (3,4,5)
    for x in tuple1:
     print(x)

    # output: 3 4 5
    ```

  - Membership

    - Check if any specific item or data is inside the tuple.

    ```python
    tuple1= ("red", "yellow", "blue")
    print("red" in tuple1)

    # output: True
    ```

## Sets and operations on Sets

- Set are unordered data type in python which are mutable which means their data can be changed and edited by time. each element in set is different and unique.
- Sets can contain different type of data in it.

```python
example_set = { 23, "Hii" , 2.3, "H"}
```

- This data can be accessed using indexing.
- How to create set?

  - sets in python can be created using `{}` curly braces and that is set is stored inside a variable with which we can access the set later.

  ```python
  example_set = {1,3,45,5,5,2}

  print(example_set)
  ```

- Characteristics of set
  - Set is unordered data type.
  - Set is mutable which means their data can be edited with time.
  - Data in the set is different and unique, no data are same.
  - Data can be accessed using indexing.
  - It can contain multiple type of data.
- Operations on set

  - pop()

    - Pop operations removes any random element from the set and returns the removed element and returns the set in ordered manner.

    ```python
    example_set = {3,6,3,6,4}

    popped_element = example_set.pop()
    print(popped_element)
    print(example_set)

    # output:
    # 3
    # {4,6}
    ```

  - add()

    - using add function we can add new elements to set

    ```python
    example_set = {"this", "is", "example"}
    example_set.add("set")
    print(example_set)

    # output
    # this is example set
    ```

  - remove()

    - using remove function we can remove any element from the set

    ```python
    example_set = {"this", "is", "extra", "word"}
    example_set.remove("extra")
    print(example_set)

    # output
    # this is word
    ```

## Dictionaries and operations on Dictionaries

- Dictionaries are used to store data values in key and values pairs.
- A dictionary is a collection which is ordered and changeable.
- it does not allow duplicates.
- it is mutable data type.
- Dictionary has two values within the set,
  - key: with which we can target the specific data.
  - value: the value we can store in key.
- dictionary works almost same as variables only difference is we can store multiple variables in single dictionary and target dictionary to access the variable.
- Syntax

```python
new_dict = {
 "key": "value",
 "key1": "value1"
}
```

- Characteristics of dictionaries
  - They are mutable which mean we can change their data.
  - It does not allow duplication of data.
  - The data in dictionary are ordered data.
  - We can access the value of pair within dictionary by targeting the dictionary itself
- Operations on dictionaries

  - clear()

    - Removes all the elements from the dictionary.
    - syntax

    ```python
    my_dict = {
     "one": 1,
     "two": 2,
     "three": 3
    }

    my_dict.clear()
    ```

  - copy()

    - return copy of a dictionary.

    ```python
    my_dict = {
     "one": 1,
     "two": 2,
     "three": 3
    }

    my_dict.copy()
    ```

  - pop()

    - Removes the element with specified key.

    ```python
    my_dict = {
     "one": 1,
     "two": 2,
     "three": 3
    }

    my_dict.pop("three")
    ```

  - update()

    - updates the dictionary with new key-value pairs.

    ```python
    my_dict = {
     "one": 1,
     "two": 2,
     "three": 3
    }

    my_dict.update({
     "four": 4
    })
    ```

  - values()

    - Returns a list of all the values in the dictionary.

    ```python
    my_dict = {
     "one": 1,
     "two": 2,
     "three": 3
    }

    my_dict.values()
    ```

  - get ()

    - Used to get value from specific key.

    ```python
    my_dict = {
     "one": 1,
     "two": 2,
     "three": 3
    }

    my_dict.get("three")
    ```
]]></description>
        </item>
        <item>
            <title><![CDATA[4 - Functions and Modules - Python]]></title>
            <link>https://dracodemy.vercel.app/posts/4---functions-and-modules---python</link>
            <guid>https://dracodemy.vercel.app/posts/4---functions-and-modules---python</guid>
            <pubDate>Mon, 01 Jan 2024 00:00:00 GMT</pubDate>
            <description><![CDATA[
## Introduction to python user defined function

- User defined function are kind of functions which are defined by user in python program to do some specific tasks with specific requirements.
- To define a function in python we use `def` keyword which means define.
- syntax:

  ```python
  def function_name(parameters)
    # code
  ```

- example:

  ```python
  def print_hello():
    print("hello world!")

  print_hello()

  # output:
  # hello world!
  ```

## Passing parameters to a function

- Parameters are basically placeholder which are used in a lot function to get actual value for the specific data inside of a function.
- They work as a variable when we call a function.
- syntax:

  ```python
  def function_name(parameter):
    x = <parameter>
    print(x)

  function_name(parameter)
  ```

- example:

  ```python
  def pr  nt_name(name):
   x = name
    print("Hello, ", name)

  print_name("Preet")

  # output:
  # Hello, Preet
  ```

## Standard Library: Built-in functions

- python has very large collection of built in functions which are used by user to make things easy in the program to be executed.
- these are kind of function which doesn’t require any installation or importing external data.
- we can use these functions directly in our code by calling them with identifier.
- here are few of the built-in function in python,
- len()
  - len function is used to find length of passed object.

  ```python
  my_list = [1,3,545,6,7,3,6]
  print(len(my_list))
  ```

- print()
  - print function is used to print any output on our console.

  ```python
  print("Hello world")
  print(143)
  ```

- input()
  - input function is used to take input from user, store it in variable and use later in our python program.

  ```python
  age = input("Enter your age: ")
  print("User is ", age, " years old!")
  ```

- type()

  - type function is used to find type of any object.

  ```python
  my_str = "Hello world!!"
  my_int = 143

  print(type(my_str))
  print(type(my_int))
  ```

- min()
  - min function is used to find minimum value from passed parameters.

  ```python
  print(min(3,5,2,5,7,3,1))
  ```

- max()
  - max function is used to find maximum value from passed parameters.

  ```python
  print(max(3,5,2,6,8,234,456,33,3))
  ```

- sum()
  - sum function is used to sum up two passed parameters.

  ```python
  x = 10
  y = 20
  print(sum(10,20))
  ```

- etc.

## Modules and Packages

## Random Module

- Random module in python is used to generate any random sequence of numbers or any other data.
- This module is pre-installed in python so it doesn’t require any external installation.
- we can start using it by importing in our file — `import random`
- this module can help to generate series of random numbers or data.
- here are few function from the random module
  - `random.random()`
    - Returns random number between 0 and 1
    - 0.34244
  - `random.randint()`
    - returns random integer.
  - `random.range()`
    - generate sequence of number or data from given range.
  - `random.randrange()`
    - generates series with random range.
  - `random.choice()`
    - chooses random data from the given object.
- Example:

  ```python
  import random

  my_list = ["red", "blue", "green"]
  random_color = random.choice(my_list)

  print(random_color)

  # output:
  # red
  ```

## Math Module

- Math module in python is used to perform mostly all math function inside of python program.
- It is very useful when we have to perform such complex mathematic equation in our program to get some specific data.
- It is pre-installed in python programming language which means it doesn’t require any external installation to start using this module.

```python
import math
```

- Here are few function from the math module
  - `math.sum()`
    - Returns sum of two numbers

    ```python
    math.sum(10,20)
    ```

  - `math.pow()`
    - Return answer of A to the B

    ```python
    math.pow(a,b)
    ```

  - `math.exp()`
    - Returns exponential of the number

    ```python
    math.exp(65)
    ```

  - `math.asin()`
    - Returns Arc sin of a number.
  - `math.acos()`
    - Returns Arc cos of a number.
  - `math.atan()`
    - Returns Arc tan of a number.
  - `math.sin()`
    - Returns sin of a number.
  - `math.cos()`
    - Returns cos of a number.
  - `math.tan()`
    - Returns tan of a number.
  - `math.log()`
    - Returns log of given number.
  - `math.sqrt()`
    - Returns Square root of given number.

    ```python
    math.sqrt(25)
    ```

  - `math.fact()`
    - Returns factorial of given number.

    ```python
    math.fact(25)
    ```

## Datetime Module

- Datetime module in python is very useful module to easily manage the dates and current time data in program.
- It is pre-installed module in python so it doesn’t require any external installation.

```python
import datetime
```

- Datetime module has vast collection of datetime functions and methods.
- Here are few function from the datetime module.
- `datetime.date()`
  - Returns the current date.
- `datetime.time()`
  - Returns the current time.
- `datetime.datetime()`
  - Returns the current date and time.
- `datetime.timedelta()`
  - Returns the difference in date or time at any given point.
- `datetimte.tzinfo()`
  - Returns time zone information.
- `datetime.timezone()`
  - Returns time zone information with recent version of UTC.

## Matplotlib Module

- Matplotlib means Math plot library.
- This is used to plot visual graph in python program for some specific data set or any online data.
- This isn’t pre-installed in python so it requires installation before usage.

```python
pip install matplotlib
```

- matplotlib allows us wide variety of plots which helps to understand trends and patterns. Here are few of them listed,

  - Matplotlib Line Plot

    - This plotting is used to plot graph with line visual.

    ```python
    from matplotlib import pyplot as plt
    x = [2,4,6]
    y = [2,7,2]

    plt.plot(x,y)
    plt.show()
    ```

  - Matplotlib Bar Plot

    - This plotting is used to plot graph with bar visual.

    ```python
    from matplotlib import pyplot as plt
    x = [4,3,7]
    y = [2,6,8]

    plt.bar(x,y)
    plt.show()
    ```

  - Matplotlib Histogram Plot

    - This plotting is used to plot graph with histogram visual.

    ```python
    from matplotlib import pyplot as plt
    x = [3,5,2]
    y = [8,7,3]

    plt.hist(x,y)
    plt.show()
    ```

  - Matplotlib Scatter Plot

    - This plotting is used to plot graph with scatter visual.

    ```python
    from matplotlib import pyplot as plt
    x = [3,5,2]
    y = [8,7,3]

    plt.scatter(x,y)
    plt.show()
    ```

  - Matplotlib Pie Plot

    - This plotting is used to plot graph with pie visual.

    ```python
    from matplotlib import pyplot as plt

    label = ["Day 1", "Day 2", "Day 3"]
    sizes = [35,35,30]

    plt.pie(sizes, labels=label)
    plt.title("Pie chart example")
    plt.show()
    ```

## Create and import custom user defined modules

- creating custom user defined modules is very simple task here is how we can achieve that.
- first create a file named `matho.py`
- now inside that file we define our user defined functions.

```python
def sum(x,y):
  return x + y
def sub(x,y):
  return x - y
def multi(x,y):
  return x * y
def mod(x,y):
  return x % y
def div(x,y):
  return x / y
```

- now in our main file `main.py` we can import our user defined module

```python
import matho.py

a = 10
b = 20

print(matho.sum(a,b))
print(matho.sub(a,b))
print(matho.multi(a,b))
print(matho.mod(a,b))
print(matho.div(a,b))
```

- This is the most basic yet effective method to create user-defined functions and actually import them in our main file and use them easily.
]]></description>
        </item>
        <item>
            <title><![CDATA[5 - Normalization | RDBMS]]></title>
            <link>https://dracodemy.vercel.app/posts/5---normalization-rdbms</link>
            <guid>https://dracodemy.vercel.app/posts/5---normalization-rdbms</guid>
            <pubDate>Fri, 12 Jan 2024 00:00:00 GMT</pubDate>
            <description><![CDATA[
## Basics of Normalization

- Normalization is method or technique used to eliminate data redundancy and ensures the data integrity between tables.
  - It decreases data redundancy.
  - It ensures the data integrity of tables.
- There are three types of Normalizations

  - 1NF (First Normal Form)
  - 2NF (Second Normal Form)
  - 3NF (Third Normal Form)

- 1NF (First Normal Form) -

  - First normal form in this table the data should not be repeating in single row.
  - Every row and data must be unique.

  ![Untitled](https://i.imgur.com/YIM5w8l.png)

  - In above example we have two author data in single column and single row.
  - Now if we use First Normal Form we eliminate the repeating data.

  ![Untitled](https://i.imgur.com/p2E6ueW.png)

- 2NF (Second Normal Form) -

  - It is already in First Normal Form, which means each row and data is unique.
  - All data are fully dependent on primary key.
  - It divides tables in multiple tables which helps to improve data integrity and reduce data redundancy.
  - It helps to organize the data and tables in database.

  ![Untitled](- It is already in First Normal Form, which means each row and data is unique.)

  - In above example we have where CourseID is primary key and there are total 3 columns,
  - Now using Second Normal Form we can divide the data referencing primary key in other tables.

  ![Untitled](https://i.imgur.com/9glCn3L.png)

  ![Untitled](https://i.imgur.com/1mVGBA1.png)

- 3NF (Third Normal Form) -

  - Must be Second Normal Form before Third Normal Form.
  - No non-key attributes are directly dependent on the primary key

    ![Untitled](https://i.imgur.com/JK8Tid3.png)

  - Now using Third Normal Form we can divide single table into two tables using one of the column data and referencing a column from one table into another table.

    ![Untitled](https://i.imgur.com/EkneCxa.png)

    ![Untitled](https://i.imgur.com/tvH0aoC.png)

## Advantages of normalization —

- Reduces data redundancy and inconsistency.
- Helps achieving data integrity.
- Provides clear structure to the data.
- Makes data retrieval more efficient.
- By organizing data it'll enhances the reliability of the database.
- Normalization improves performance of the database and makes it faster.

## Disadvantages of normalization —

- Very complex to implement.
- May require extra joins in tables to make it work.
- Makes the structure complex which can slow down the queries and processes.
- It increases the database size.
- Using normalization it can reduce flexibility.
]]></description>
        </item>
        <item>
            <title><![CDATA[5 - String Processing and File Handling - Python]]></title>
            <link>https://dracodemy.vercel.app/posts/5---string-processing-and-file-handling---python</link>
            <guid>https://dracodemy.vercel.app/posts/5---string-processing-and-file-handling---python</guid>
            <pubDate>Tue, 02 Jan 2024 00:00:00 GMT</pubDate>
            <description><![CDATA[
## Introduction to String

- Strings are basically sequential collection of characters.
- It is immutable data type which means once you have created a string you cannot change it.
- Strings are written inside double quotation mark `"like this"`
- example strings:

```python
"This is string"

"""
This is
multiline
string
"""

'''
So this
is multiline
Too
'''
```

- Creating a string in python

  - To create a string you don’t have to define specific data type in python.
  - Because python is dynamically written language you don’t have to define any type of data while creating variables.
  - so strings are basically array of characters.
  - but in python you don’t have to create array or array of characters to create a string, you can easily create a string just by creating a string variable.
  - example:

  ```python
  my_string = "This is my string"
  ```

  ```python
  my_string = "Hello world!"
  print(my_string)

  # output:
  # Helllo world!
  ```

## Access string elements using indexing

- Usually every object in python has indexes with which we can access the specific data from specific set
- These index are used to target specific data from specific element.

![Accessing elements using indexing](https://i.imgur.com/iInZ6lb.png)

- Index always starts with 0.
- for example
  - `index 0 == 35`
  - `index 7 == 44`
- Using this same indexes we can access specific data in python.
- example:

```python
list1 = ["I0", "I1", "I2", "I3"]

print(list1[0]) # here [0] represent index number

# output:
# I1 (I1 = Index 1)

print(list1[2])

# output:
# I2 (I2 = Index 2)
```

## String functions

### Basic functions

- `len()`

  - len function is used to get length of specified string

    ```python
    my_str = "1234567890"
    print(len(my_str))
    ```

### Testing functions

- `isalnum()`

  - Returns true if specified string is in alpha numeric format.

    ```python
    print(isalnum(str))
    ```

- `isalpha()`

  - Returns true if specified string is in alphabetic format.

    ```python
     print(isalpha(str))
    ```

- `isdigit()`

  - Returns true if specified string is in numeric format.

    ```python
    print(isdigit(str))
    ```

- `isidentifier()`

  - Returns true if specified string is an identifier.

    ```python
    print(isidentifier(str))
    ```

- `islower()`

  - Returns true if specified string is in lower text format.

    ```python
    print(islower(str))
    ```

- `isupper()`

  - Returns true if specified string is in upper text format.

    ```python
    print(islower(str))
    ```

- `isspace()`

  - Returns true if specified string is space.

    ```python
    print(isspace(str))
    ```

### Searching functions

- `endswith()`

  - Returns True if specified string ends with passed parameter.

    ```python
    my_str = "Hii John"
    print(my_str.endswith("John")
    ```

- `startswith()`

  - Returns True if specified string starts with passed parameter.

    ```python
    my_str = "Hii John"
    print(my_str.startswith("Hii")
    ```

- `find()`

  - Returns the index number if specified parameter is found.

    ```python
    my_str = "Hello world, I'm AI."
    print(my_str.find("Hello"))

    # output
    # 6
    ```

- `count()`

  - Returns the total count of text or number which has been repeated in the string.

    ```python
    my_str = "Repeat, Repeat, Repeat, The output for Repeat word should be 4""
    print(my_str.count("Repeat") # we have wrote "Repeat" 4 times.

    # output
    # 4
    ```

### Manipulation functions

- `capitalize()`

  - Capitalize first character of the first word in string.

  ```python
  my_str = "hii there!"
  print(my_str.captitalize())

  # output
  # Hii there!
  ```

- `lower()`

  - Lowercase all characters in the string

  ```python
  my_str = "THIS IS UPPERCASE"
  print(my_str.lower())

  # output
  # this is uppercase
  ```

- `upper()`

  - Uppercase all characters in the string

  ```python
  my_str = "this is lowercase"
  print(my_str.upper())

  # output
  # THIS IS LOWERCASE
  ```

- `title()`

  - Gives title format to entire string.

  ```python
  my_str = "make This title format"
  print(my_str.title())

  # output
  # Make This Title Format
  ```

- `swapcase()`

  - Swaps cases in entire string
  - Uppercase → lowercase
  - Lowercase → Uppercase

  ```python
  my_str = "tHIS iS MiXCase"
  print(my_str.swapcase())

  # output
  # This Is mIxcASE
  ```

- `replace()`

  - Replace function is used to replace specific words to specific word in string.
  - `str.replace("<replace_this>", "<with_this>")`

  ```python
  my_str = "Hii world!"
  print(my_str.replace("Hii", "Hello")

  # output
  # Hello world!
  ```

## File Handling

- Python has inbuilt feature to handle files via python program, it’s called “File Handling”.
- Using File Handling we can read, write, append, delete and do a lot of operations on file and file data.
- Here are file methods,
- `w` - Write only
- `w+` - Write and Read
- `r` - Read only
- `r+` - Read and Write
- `a` - Append only
- `a+` - Append and Read

- `open()`

  - We use open() function to open file.

  ```python
  my_file = file.open("readme.txt", w+)
  ```

- `close()`

  - We use close() function to close opened file.

  ```python
  my_file.close()
  ```

## File Handling Functions

### Basic Functions

- `open()`

  - We use open() function to open file.

  ```python
  my_file = file.open("readme.txt", w+)
  ```

- `close()`

  - We use close() function to close opened file.

  ```python
  my_file.close()
  ```

### Reading File

- `read()`

  - Using read function we can read entire file.

  ```python
  my_file = file.open("readme.txt", r)
  print(my_file.read())
  ```

- `readline()`

  - Using readline function we can read just single line from the file.

  ```python
  my_file = file.open("readme.txt", r)
  print(my_file.readline())
  ```

- `readlines()`

  - Using readlines function we can read multiple lines from the file.

  ```python
  my_file = file.open("readme.txt", r)
  print(my_file.readlines())
  ```

### Writing File

- `write()`

  - Using write function we can write data in a file.

  ```python
  my_file = open("writeme.txt", w)
  my_file.write("Helloo world!!")
  ```

- `append()`

  - Using append function we can add new text at the last of the file, only at the end of the file.

  ```python
  my_file = open("writeme.txt", w)
  my_file.append("This text was added at the end.")
  ```

- `writelines()`

  - Using writelines function we can add multiple lines in the file.

  ```python
  my_file = open("writeme.txt", w)
  L = [str1, str2, str3]

  my_file.writelines(L)


  ```
]]></description>
        </item>
        <item>
            <title><![CDATA[Basics Data Structure & Algorithm - Lecture 1]]></title>
            <link>https://dracodemy.vercel.app/posts/basics-data-structure-algorithm---lecture-1</link>
            <guid>https://dracodemy.vercel.app/posts/basics-data-structure-algorithm---lecture-1</guid>
            <pubDate>Mon, 28 Aug 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[
## Data Structure

- It is a way of storing and organizing data in the computer system, which can be used and accessed efficiently.
- It is a technique or method of studying how the data are interrelated to each other logically or mathematically.
- The study of _Data structure_ covers following points,
  - the amount of memory required to store data.
  - Amount of time required to process data.

### Data

- Collection of any information or facts with keys and values which can be late accessed.
- It is processed and organized in a meaningful way.

### Information

- When a lot of data is processed returns some details which are called "information"
- It is created in the form of data.

![Diagram](https://github.com/preetsuthar17/basic-DSA-notes/assets/75468116/50db56ac-6411-45eb-97cd-9e7f0e87e63b)

### Cell

The specific location in memory where data can be stored is called a "Cell".

- It can be referred to as a single bit, Byte, or group of Bytes.

### Field

- The smallest piece of information that can be stored in the data structure.

### Record

- Collection of information about particular items.

### File

- Collection of records

![Diagram](https://github.com/preetsuthar17/basic-DSA-notes/assets/75468116/53cfecb2-7f4c-49f7-bc35-ae74c3deaa6e)

## Advantages of Data Structure

1. The data is stored in the hard drive of the computer.
2. Changes or manipulation in the value of data structure can be done easily.
3. Data can be accessed easily anytime anywhere.
4. Data structure provides models for real-life problems

## Application of Data Structure

1. It can be used for compiler designs.
2. It can be used for computer graphics.
3. Also it is used in operating systems.
4. For database management system.
5. Artificial intelligence and more...

## Types of Data Structure

Let's see types of data structure without deep diving, into the basics.

1. Primitive:
   - It contains fundamentals for basic datatypes
   - For example, Int, Float, Boolean
2. Non-primitive:
   - User-defined datatypes created and derived using primitive datatypes.
   - For example, Structure, Class, Union
3. Linear data structure:
   - Type of data structure where data is stored with a particular sequence.
   - For example, Arrays, Queue, Stacked.
4. Non-Linear data structure:
   - Type of data structure where data is stored without a particular sequence. [Randomly]
   - For example, Tree, Graph.
5. Homogeneous data structure:
   - Type of data structure where data is stored with similar types of data.
   - For example, Arrays.
6. Non-Homogeneous structure:
   - Type of data structure where the datatype of data doesn't need to be similar to Homogeneous.
   - For example, Structure, Class.
7. Static data structure:
   - In this data structure the values are fixed in memory which cannot be changed in run time.
   - No expansion in memory during runtime.
8. Dynamic data structure:
   - Changes can be made in runtime.
   - No fixed memory value.
   - possible to expand memory areas by adding or deleting data.
]]></description>
        </item>
        <item>
            <title><![CDATA[Basics Data Structure & Algorithm - Lecture 10]]></title>
            <link>https://dracodemy.vercel.app/posts/basics-data-structure-algorithm---lecture-10</link>
            <guid>https://dracodemy.vercel.app/posts/basics-data-structure-algorithm---lecture-10</guid>
            <pubDate>Wed, 20 Sep 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[
## Stack and Queues

## Stack

- It is non-primitive linear Data Structure where you can insert and delete values at the same End also known as Top of Stack.

![stack](https://i.imgur.com/B6MvXk5.png)

- Stack is also known as LIFO - Last in First Out.
- Which means the values inserts last in stack is the value gets deleted first.
- To insert any value at end of stack you have to delete all of the top values and then insert new value.
- Whenever stack is empty the top stack value is "0" or "-1".

## Properties of Stack

- Insertion operation in stack is called "Push Operation".
- Deletion operation in stack is called "Pop Operation".
- A pointer at top always keeps track of top elements in stack.
- Initially when stack is empty top has value of "Zero (0) " and when stack contain single element top has value of "One (1)" and this value increases according to insertion in stack and decreases according to deletion.
- Each time new element insert in stack the top pointer is incremented by "One (1)" and decrement by "One (1)" when element delete.

## Operations on Stack

- Stack has two operations:
  - 1. Push
  - 2. Pop

## Stack operation - Push

- Push operation means adding.
- Push operation is used to insert any new value in stack
- After every push operation the top of stack value is increased by 1.
- When you try to insert value in stack when stack is full, you create condition which is called `Stack Full condition` or `Stack overflow condition`.

### Stack Push Algorithm

```plain
Step 1: [Initialization]
if ( top >= N)
then write("Stack overflow)
return ()

Step 2:
Top = Top + 1

Step 3:
S[Top] = X

Step 4: [Finish]
Return ()
```

## Stack operation - Pop

- Pop operation means delete.
- Pop operation is used to delete any value from stack.
- After every pop operation the top of stack value is decreased by 1.
- When you try to delete value from stack when stack is empty, you create condition which is called `Stack underflow condition`

### Stack Pop Algorithm

```plain
Step 1:
if (Top = 0)
then write("Stack Underflow")
return ()

Step 2:
Y <- S[Top]

Step 3:
Top <- Top - 1

Step 4:
return()
```
]]></description>
        </item>
        <item>
            <title><![CDATA[Basics Data Structure & Algorithm - Lecture 11]]></title>
            <link>https://dracodemy.vercel.app/posts/basics-data-structure-algorithm---lecture-11</link>
            <guid>https://dracodemy.vercel.app/posts/basics-data-structure-algorithm---lecture-11</guid>
            <pubDate>Wed, 03 Jan 2024 00:00:00 GMT</pubDate>
            <description><![CDATA[
## Queue

- Queue is a linear data structure where insertion and deletion operations are performed at the both end.
- Queue is also known as FIFO (first in first out) because the element which was inserted first is deleted first.
- A queue is like ticket window, where whoever comes first, gets served first.

![Untitled](https://i.imgur.com/mHrjzNg.png)

- In a queue there are two ends, front-end and rear-end.
- Insertion in queue is done from rear-end which is called enqueue.
- Deletion in queue is done at the front-end which is called dequeue.
- Characteristics of queue:
  - Queue can handle multiple data.
  - In queue we can access both ends.
  - Queue is fast and flexible.
- Operations on queue:
  - Insertion
  - Deletion
  - Traversing
- Types of Queue
  - Singular Queue
  - Circular Queue.

## Concept of Circular Queue

- Circular queue is normal queue but looped in circular manner.
- Circular queue doesn’t have any null character at the end.
- The manner of circular queue is set in a way that no number of memory wastes.
- All the data in circular queue are looped and start pointer is connected with the last pointer.

  ![Untitled](https://i.imgur.com/bS7DP5P.png)

- Circular queue doesn’t waste any memory like normal queue.
- When element is deleted in normal queue the space that it left becomes non-usable.
- Where the circular queue it takes the empty space and make good use of it.
- Operations on circular queue:
  - Insertion (Enqueue)
  - Deletion (Dequeue)
  - IsEmpty/IsFull
- Application of circular queue:
  - Memory management
    - Circular queue is used in memory management
  - Process Scheduling
    - A CPU uses a queue to schedule processes.
  - Traffic System
    - Queues are also used in traffic systems.

## Application of Queue

- Task Scheduling
  - Queues can be used to manage and schedule the task based on priority or the order in which they were received.
- Operating System
  - Operating systems often uses Queue to manage the task of processing and resources.
- Resource Allocation
  - Queues can be used to manage and allocate the resources to task based on their priority or in the order they were received.
- Batch Processing
  - Queues can be used to handle batch processing jobs such as data analysis or image rendering.
- Web Servers
  - Queues can help to manage incoming client requests and outgoing server data efficiently.
- Printer queues
  - Queues in printer helps to manage queue of pending prints.

## Differentiate circular queue ad simple queue

| Simple Queue                                                     | Circular Queue                                             |
| ---------------------------------------------------------------- | ---------------------------------------------------------- |
| Elements are in sequential and linear manner.                    | Elements are in circular manner loop through entire queue  |
| Insertion is done from rear-end and deletion from the front-end. | Insertion and deletion can be done from any place any end. |
| Memory space is more occupied than circular queue.               | Memory space is less occupied than simple Queue            |
| The usage of memory is inefficient.                              | The memory can be more efficiently utilized.               |
| It follows FIFO principle (First in First Out)                   | It doesn’t have any specific manner                        |
]]></description>
        </item>
        <item>
            <title><![CDATA[Basics Data Structure & Algorithm - Lecture 12]]></title>
            <link>https://dracodemy.vercel.app/posts/basics-data-structure-algorithm---lecture-12</link>
            <guid>https://dracodemy.vercel.app/posts/basics-data-structure-algorithm---lecture-12</guid>
            <pubDate>Thu, 04 Jan 2024 00:00:00 GMT</pubDate>
            <description><![CDATA[
## Revision of Pointers

### Pointer -

- A pointer is a variable that stores the memory address of another variable as its value.
- It is done using reference operator `&`.
- A pointer variable points to a datatype of the same type, and is created with `*` operator.
- Syntax:

  ```python
  int my_var = 10;
  int* ptr = &my_var;
  ```

- In above example the memory address of `my_var` is stored in pointer called `ptr`
- Let’s access those values and print in console

  ```c
  int my_var = 10;
  int* ptr = &my_var;

  // print value of my_var
  printf("%d\n", my_var);

  // print memory address of my_var without using pointer.
  printf("%n\n", &my_var);

  // print memory address of my_var using pointer.
  printf("%p\n", ptr);
  ```

## Revision of Structure

### Structure -

- A structure in programming language is a user-defined data type.
- They are used to group multiple related variables at single place.
- Each variable in structure is known as `member`.
- A structure can contain multiple type of data like float, int, char, etc.

### Creating Structure

- To create a structure we use `struct` keyword and all the member are declared inside the curly braces `{}`

```c
struct myStructure { // declaration
 int myNum; // member
 char myLetter; // member
}; // Ends with semicolon
```

### Accessing structure and members inside of structure

- To access structure we must create a variable of a structure.
- We use `struct` keyword inside `main()` function following by identifier.

```c
struct myStructure{
 int myAge;
 int mySal;
};

int main(){
 struct myStructure s1;

 return 0
}
```

- Now to access the structure members we use structure variable following by member name.

```c
struct myStructure{
 int myAge;
 int mySal;
};

int main(){
 struct myStructure s1;

 s1.myAge = 17;
 s1.mySal = 69000;

 printf("My age: %d\n My salary: %d\n", s1.myAge, s1.mySal);

 return 0
}
```

## Dynamic Memory Allocation

- Dynamic memory allocation in programming language allows the programmer to allocate the memory at runtime.
- There are 4 function for the memory allocation in C programming language.

  1. malloc()
  2. calloc()
  3. realloc()
  4. free()

### malloc()

- malloc function allocates single block of requested memory.
- It doesn’t initialize memory at execution time, so it has garbage value initially.
- It returns null if memory is not sufficient.
- syntax

  ```c
  ptr = (cast_type*)malloc(byte_size)
  ```

- example

  ```c
  ptr = (int*)malloc(n*sizeof(int)); // we're allocating the size of int datatype
  ```

### calloc()

- calloc function allocates multiple block of requested memory.
- It initially initialize all bytes to zero.
- It returns null if memory is not sufficient.
- syntax

  ```c
  ptr = (cast_type*)calloc(number, byte_size);
  ```

- example

  ```c
  ptr = (int*)calloc(10, sizeof(int)); // we're allocating the size of  int datatype to 10 blocks in memory
  ```

### realloc()

- if memory is not sufficient for malloc() or calloc() you can reallocate the memory by realloc() function.
- basically it changes the memory size.

```c
ptr = realloc(ptr, new_size)
```

### free()

- free function is used to release the memory occupied by malloc or calloc functions

```c
free(ptr)
```

## Linked list presentation

- Linked list is a linear data structure just like array.
- The elements in linked list are connected using pointers.
  ![Untitled](https://i.imgur.com/dkktSQh.png)
- Linked list is basically multiple nodes connected together making a sequence of nodes.
- It has NULL at the end of linked list, which shows that the linked list is ended
- Each node contains two field,
  - Data
  - Next(pointer)
- Data:
  - It contains the data of variable.
- Next(pointer):
  - It contains the memory address of next data.
    ![Untitled](https://i.imgur.com/1KhIabX.png)
- Starting point of linked list is known as Head, and ending point is known has Tail
- Operations on Linked List
  - Insertion
  - Deletion
  - Traversal
  - Searching
  - Sorting
  - Merging

## Types of linked list

- There are multiple types of Linked List
  - Singly Linked List
  - Doubly Linked List
  - Circular Linked List
  - Circular doubly Linked List

### Singly linked list -

- A singly linked is single directional linked list, which means we can traverse in only one direction, i.e., from head node to tail node.
- It is sequence of nodes, where node contains data and pointer/next which points to next node.
- Last node is Null.
- It’s linear data structure which means elements are sequentially connected.
  ![Untitled](https://i.imgur.com/MPdyMFr.png)

### Applications of singly linked List

    - Implementing stacks and queues.
    - Dynamic memory allocation.
    - Undo - Redo functionality.
    - media playback applications

## Concept of circular linked list

- A circular linked list is another variation of linked list, but in this linked list the last node don’t have any null character but the last node is connected to first node forming a circular loop.
- This makes the data structure without endpoints
  ![Untitled](https://i.imgur.com/LNdUwOa.png)
- Here you can see the end tail don’t have any NULL character but instead the last character is connected with the first node.
- It forms a circular loop, which allows user to traverse the list infinitely.
- Each node contains data and pointer to next node.

### Advantages of circular linked list -

- Used to implement continual traversal like playing playlists on loop.
- Cancels the need to check for the null character which allows traversal infinitely.
- Can turn any linked list into a circular one by making the last node’s next pointer reference the first node.

### Applications of circular linked list -

- Used to implement circular buffers.
- Used to implement OS and browser forward and backward navigation while referencing the next or previous node.
- Used in Operating Systems to take note of processing.
- Used for round robin scheduling algorithms.
- Used to task scheduling in Operating Systems.

## Difference between circular linked list and singly linked list

| Circular Linked List                                                                                        | Singly Linked List                                                                                                                |
| ----------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------- |
| The last node points to the first node.                                                                     | The last node doesn’t point to any node but instead it’s NULL.                                                                    |
| Circular linked list doesn’t have any ending point instead the ending point is referenced to starting node. | Singly linked list have ending point where the ending point is defined with NULL.                                                 |
| Circular linked list can be traversed infinitely as they don’t have any ending pointer.                     | In Singly linked list the traversal is finite because it has NULL node at the end, and can be only traversed in single direction. |
| Used for queues, buffers or turn-based games etc.                                                           | Used for stacks, undo functionality, hash table chaining etc.                                                                     |

## Doubly linked list

- Doubly linked list is another type of linked list, which is also sequenced collection of nodes.
- The doubly linked list is different than singly linked list because the node and traversing has different field and methods.
  ![Untitled](https://i.imgur.com/3rNB8JT.png)
- In double linked list the node has three fields.
  - prev
    - points to the next pointer of prev node.
  - data
    - contains data of the node.
  - next
    - points to the prev pointer of next node.
- This takes more memory compared to singly linked list.
- Insertion and deletion of node is more efficient since no traversal is required to find the previous node.
- Nodes are linked together because of that the traversal is done in both direction.
- Application of Doubly Linked List -
  - Creating and navigating in both direction browser or OS to traverse forward and backwards.
  - Implementing Undo and Redo functionality by storing the data in previews and storing the data in forward data.
  - Music and video player to allow next and previous song navigation.
  - Image viewer application to allow viewing photos in an album forth and back.

## Difference between Doubly linked list and singly linked list

| Singly Linked List                                 | Doubly Linked List                                     |
| -------------------------------------------------- | ------------------------------------------------------ |
| Contains one pointer to next pointer               | Contains pointers to both next and previous node       |
| Can traverse in only single direction.             | Can traverse in both direction forwards and backwards. |
| Use less memory to as it only stores next pointer. | Uses more memory as it stores two points               |
| Can be accessed from head only.                    | Can be accessed from head and tail                     |
| Simple and clean code.                             | Complex code due to two pointer.                       |
| Used in Stacks, queues, etc.                       | Used in browsers, OS, undo-redo features, etc.         |

## Applications of Linked List

- Implementing stacks and queues -
  - Linked list are used for efficient insertion and deletion of data in linear data structures.
- Undo/redo functionality -
  - Linked lists can be used to keep track of prev pointers to implement Undo/redo functionality.
- Browser history functionality -
  - Page visits in web browser’s history implemented using linked lists to track visit sequence of pages.
- Image gallery -
  - Linked list is used to create media browsing system allowing to create next and previous button to navigate media.
- Dynamic memory allocation -
  - Linked list doesn’t require reallocation of memory, this makes it useful in systems where amount of data to be stored can’t be predicted ahead of time.
]]></description>
        </item>
        <item>
            <title><![CDATA[Basics Data Structure & Algorithm - Lecture 13]]></title>
            <link>https://dracodemy.vercel.app/posts/basics-data-structure-algorithm---lecture-13</link>
            <guid>https://dracodemy.vercel.app/posts/basics-data-structure-algorithm---lecture-13</guid>
            <pubDate>Fri, 05 Jan 2024 00:00:00 GMT</pubDate>
            <description><![CDATA[
> Topics which are not mentioned in post: Conversion of General Tree to Binary Tree & Binary Tree Traversal: PreOrder, InOrder and PostOrder.

## Non-linear data Structure — Tree, Graph

### Tree

- Is hierarchical structure with root node, siblings, nodes, parent nodes, etc.
- Nodes are connected with edges/branches from parents to children.
- A node can one have one parent
- Operations on tree,
  - Traversal
  - Sorting
  - Searching
  - Insertion
  - Deletion
  - etc.

![Untitled](https://i.imgur.com/AERMKPP.png)

### Graph

- Graph is non linear data structure which is collection of nodes and edges.
- Nodes are connected with edges.
- A node can be connected back to itself through other nodes.

![Untitled](https://i.imgur.com/N0Z1xOx.png)

## Basic Terms

### General Tree -

- A tree where each node has most two child nodes.

### Forest -

- Collection of multiple trees

### Level Numbers -

- The level or depth of a node form the root with the root at level 0

### degree -

- The number of sub trees or child nodes.

### in-degree -

- Number of incoming edges to node.

### out-degree -

- Number of outgoing edges from a node.

### root node -

- Top level node forming entire tree.

### leaf node -

- A tree with no children node.

### directed edges -

- a edge with defined direction from one node to another.

### path -

- sequence of nodes connected by edges that allow traversing the graph.

### depth -

- number of edges from the root node to last specified node
- similar as level.

## Application of binary tree

### BST -

- Used Binary trees are used for efficient searching and retrieval of data, especially when the data is sorted.

### File system -

- Binary trees are used to organize files and directories in a hierarchical file system structure.

### Decision Trees -

- Binary trees can also used for decision tree which helps to manage decision making process.

### Sorting -

- binary tree are used to implement sorting algorithm to order items.

### Search engines -

- Binary trees are used in search engines to organize and index web pages.

### Priority queues -

- Binary trees can be implemented as priority queues which are data structures that allow elements to be prioritized and retrieved in specific order.
]]></description>
        </item>
        <item>
            <title><![CDATA[Basics Data Structure & Algorithm - Lecture 2]]></title>
            <link>https://dracodemy.vercel.app/posts/basics-data-structure-algorithm---lecture-2</link>
            <guid>https://dracodemy.vercel.app/posts/basics-data-structure-algorithm---lecture-2</guid>
            <pubDate>Tue, 29 Aug 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[
In this lecture we're going to cover basic about Types of Data Structure.

![image](https://github.com/preetsuthar17/basic-DSA-notes/assets/75468116/15e9c195-64ec-4714-ba22-18e74a4e2af0)

## Types

There are many types of Data Structure but in this lesson we're going to talk about two main types of data Structure.

1. Primitive Data Structure
2. Non Primitive Data Structure

### Other Types

1. Primitive Data Structure
2. Non Primitive Data Structure
3. Linear Data Structure
4. Non Linear Data Structure
5. Static Data Structure
6. Dynamic Data Structure
7. Homogeneous Data Structure
8. Non Homogeneous Data Structure

## 1. Primitive Data Structure

- The primitive data types are the fundamental datatypes.
- Example: Int Float Double, Char
- Now in the primitive, there are two types,

  - 1. Numeric:

    - Int: Numbers with positive, negative values and whole numbers basically not decimal
      - Example: 23,6,0,1
    - Real numbers or float numbers: These represent numbers having decimal points.
      - Example: 1.5, 3.534, 0.43

  - 2. Non Numeric:

    - CHAR: character type of data.
      - Example: a to OR A to Z
    - Pointer: It is a datatype that represents the memory address of a variable. Pointers can also be used to access the memory address of a variable.

  - 3. Booleans: AKA logical,
    - It can represent value either as TRUE or FALSE.
      - 0 = False, 1 = True

## 2. Non Primitive Data Structure

- These can be derived using any primitive datatype
- There are two types of Primitive Datatype

  1. Linear Data Structure:

     - Array:
       - It is a collection of similar kinds of data.
     - Stack:

       - In data structure, insertion and deletion are performed at one end only.
       - It is also known as LIFO [Last in First out]

       ![image](https://github.com/preetsuthar17/basic-DSA-notes/assets/75468116/f8069ecb-ceec-4d7f-a481-4573acdd28ab)

     - Queue:

       - In data structure, insertion at one end and deletion at the other end.
       - It is also known as FIFO [First in First out]
         ![image](https://github.com/preetsuthar17/basic-DSA-notes/assets/75468116/58b951bd-35bf-4675-9539-51b6e723ba3f)

     - List:
       - A list can be defined as a collection of variables of a number of items.
         ![image](https://github.com/preetsuthar17/basic-DSA-notes/assets/75468116/1a17c6da-322e-426a-81fd-465b924b38f8)

## 2. Non-linear Data Structure

- Tree: [We'll learn more about this in upcoming lectures]
  ![image](https://github.com/preetsuthar17/basic-DSA-notes/assets/75468116/9ed3cd66-8dae-407a-90ab-d54c3daec6fd)

- Graph:
  - It is a collection of vertices (Node) and edges.
    ![image](https://github.com/preetsuthar17/basic-DSA-notes/assets/75468116/2682c258-a635-4baf-bff4-fc279b2bc3d9)

> More details will be covered in upcoming lectures.
]]></description>
        </item>
        <item>
            <title><![CDATA[Basics Data Structure & Algorithm - Lecture 3]]></title>
            <link>https://dracodemy.vercel.app/posts/basics-data-structure-algorithm---lecture-3</link>
            <guid>https://dracodemy.vercel.app/posts/basics-data-structure-algorithm---lecture-3</guid>
            <pubDate>Wed, 30 Aug 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[
## Let's talk about operations we can perform on data structures

Here operations basically means changing the existing data structure or creating a new one.

## Operations on primitive data structure

1. Creation:
   - This operation is used to create a new data structure.
2. Destroy:
   - This operation is used to delete or destroy a new data structure.
     - For example: `free function`
3. Selection:
   - This operation is used to access data structure.
4. Update:
   - This operation is used to commit or make new changes or update data structure.

## Operations on non-primitive data structure

1. Transversing:
   - Transversing means each element in the data structure is accessed and processed at least once.
2. Sorting:
   - It means arranging elements in the data structure with some logical order.
3. Searching:
   - Searching means finding the location of the element with a given key value.
4. Merging:
   - It is the process of combining different elements into one sorted list.
5. Insertion:
   - Adding a new element to the data structure.
6. Deletion:
   - Deleting specific items from the data structure.
7. Splitting:
   - It is the process of partitioning a single list into multiple lists.
]]></description>
        </item>
        <item>
            <title><![CDATA[Basics Data Structure & Algorithm - Lecture 4]]></title>
            <link>https://dracodemy.vercel.app/posts/basics-data-structure-algorithm---lecture-4</link>
            <guid>https://dracodemy.vercel.app/posts/basics-data-structure-algorithm---lecture-4</guid>
            <pubDate>Thu, 31 Aug 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[
## Introduction to Algorithm

- An algorithm is a step-by-step solution to any real-life problem.
- An algorithm is a sequence of instructions that can act on some input data to produce some output, within the limited number of steps.
- Algorithm is independent of any programming language.
- An Algorithm is not a complete code or program. it is the solution to any problem that can be expressed using pseudo code.

## Characteristics of Algorithm

- Input:
  - An algorithm must have either zero or a limited amount of input.
- Output:
  - At least one output must be generated by any algorithm.
- Definiteness:
  - Every step in the algorithm must be clear and straightforward.
- Finiteness:
  - An algorithm must be completed in a limited number of steps.
- Effectiveness:
  - Every step of an algorithm must be effective or have some meaning.
- Correctness:
  - For every input, an algorithm should produce the correct output.
- Feasibility:
  - An algorithm must be feasible [possible to implement].
- Independence:
  - An algorithm should have step-by-step direction which should be independent of any programming code.
]]></description>
        </item>
        <item>
            <title><![CDATA[Basics Data Structure & Algorithm - Lecture 5]]></title>
            <link>https://dracodemy.vercel.app/posts/basics-data-structure-algorithm---lecture-5</link>
            <guid>https://dracodemy.vercel.app/posts/basics-data-structure-algorithm---lecture-5</guid>
            <pubDate>Thu, 31 Aug 2023 18:30:00 GMT</pubDate>
            <description><![CDATA[
## Notation for Algorithm design

1. Name of algorithm:

   - Every algorithm is given an identifying name written capital letters.
   - Example:
     - ARRAY_SEARCH(option1, option2)

2. Steps:

   - The actual algorithm is made up of a number of steps each starting with a phrase enclosed in square brackets which gives a description of that step.
   - Example:
     - Step 1 [Description of step]<br/>
       Instruction.

3. Assignment statement:

   - It is indicated by placing an arrow between the right-hand side and left-hand side of the statement and the variable receiving the value.
   - Example:
     - A <- 10

4. If statement:

   - This helps to add conditions in the algorithm.
   - Example:
     - if(condition)<br/>then this<br/>else

5. Case statement:

   - The case statement is used for multiple choice type solution.

6. Repeat statement:

   - It is used to create loops in the algorithm.
     - While loop
     - For loop
   - Example:
     - Repeat while (condition)

7. Goto statement:

   - This goto statement causes unconditional transfer of control to the step referenced.

8. exit statement:
   - It is used to terminate an algorithm.

## Advantages of the Algorithm

- It is a step-by-step representation of a real-life solution.
- It is easier to understand.
- It is not dependent on any programming language.
- It can work as a blueprint for the program to develop.
- By using an algorithm the problem is broken down into smaller parts hence it is easy for a programmer to convert it into an actual program.

## Disadvantages of an Algorithm

- It is time-consuming.
- It is difficult to show branching and looping in an algorithm.
- Big problems are difficult to solve using algorithms.

## Example of an Algorithm

SUM OF TWO NUMBERS

Step 1: [Initialization]<br/>Take two inputs numbers from the user: a,b

Step 2: [Compute Sum]<br/>Sum = a+b

Step 3: [Print result]<br/> Print Sum

step 4: [Finish]
]]></description>
        </item>
        <item>
            <title><![CDATA[Basics Data Structure & Algorithm - Lecture 6]]></title>
            <link>https://dracodemy.vercel.app/posts/basics-data-structure-algorithm---lecture-6</link>
            <guid>https://dracodemy.vercel.app/posts/basics-data-structure-algorithm---lecture-6</guid>
            <pubDate>Thu, 07 Sep 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[
## Algorithm Analysis

- Task of measuring how much storage and determining how much computing time required from algorithm.

## Time complexity

- The time complexity of algorithm is defined as amount of time taken by algorithm to run its complexity

- Number of instruction which one algorithm to execute during its running time is called time complexity.

- It is machine independent

- Time Complexity represent as a function of input `t(n)` time required to execute number of steps.

- Sometimes it may happen some algorithm have different time complexity just because of its input size and number of steps executed.

## Space Complexity

- When we design an algorithm to solve problem it needs some computer memory to complete its execution.

- Total amount of computer memory required by an Algorithm to complete its execution is called space complexity.

- It is machine dependent.

- The memory is primary memory not a hard drive or removable media.

## Notations

1. Asymptotic Notation
2. Big-O-Notation
3. Omega Notation
4. Theta Notation

![Preview](https://i.imgur.com/xt0Fd2E.png)

## Asymptotic Notation

- A Asymptotic notation is used to describe the running time of an algorithm its a order of growth of function

### Uses

- They can be used to represent the complexities of algorithms for asymptotic analysis.

- They allow the comparison of the performance of an algorithm.

- To choose the best algorithm we need to check the efficiency of each algorithm.

- Asymptotic notation a short hand way to represent time complexity.

## Big-O-Notation (upper-bound; worst case)

- The big-O notation is a method representing the upper bond of algorithm running time.

- Using big-O-Notation we can give longest amount of time taken by the algorithm to
  complete.

- Let `f(n)` and `g(n)` being two non-negative functions

- Similarly `C` is some constant such that `C > 0` we can write `f(n) <= C * g(n)`

- It is also denoted as `f(n (- Og(n))`

- In other words `f(n) < g(n)` if `g(n)` is multiple of some constant.

## Omega Notation (lower bond; best case)

- Omega notation is denoted by `Ω` (omega).

- This notation is used to represent lower bound of algorithm running time.

- Using omega notation we can denote shortest amount of time taken by algorithm.

- A function `f(n)` is said to be in `Ω(g(n))` if `f(n)` is bounded below some positive constant multiple of `y(n)` such that `f(n) >= C * g(n)`

- For all `n >= no` is denoted as `f(n) (- g(n)`

## Theta Notation

- Theta notation is denoted by `Θ`

- In this method the running time is between upper bound and lower bound.

- Let `f(n)` and `g(n)` be two non-negative functions.

- There are two positive constant named `C1` and `C2`

`C1 * g(n) <= f(n) <= C2 * g(n)`

- Then we can say that `f(n) (- Θ g(n)`
]]></description>
        </item>
        <item>
            <title><![CDATA[Basics Data Structure & Algorithm - Lecture 7]]></title>
            <link>https://dracodemy.vercel.app/posts/basics-data-structure-algorithm---lecture-7</link>
            <guid>https://dracodemy.vercel.app/posts/basics-data-structure-algorithm---lecture-7</guid>
            <pubDate>Mon, 11 Sep 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[
## Arrays

- Collection of similar types of data is called an "Array".
- Array is linear data structure of similar type of value under a same name.
- Data are stored in sequence in data structure.

## Array Syntax

```
data_type arr_name[sizeof_arr]
```

### Example

```c
int ages[5] = [15,17,14,18,19]
```

This example basically means

```c
ages[0] = 15;
ages[1] = 17;
ages[2] = 14;
ages[3] = 18;
ages[4] = 19;
```

An array basically creates multiple variables with different index with which data can be accessed.

in arrays index starts from 0 to n number.
the last index will be `sizeof_arr - 1` which means we have `ages[5]` where size of arr is `5` so first index will `ages[0]` and last index will be `sizeof_arr - 1` means it'll be `5 - 1` so last index will be `ages[4]`

Values in arrays can be accessed using array index. SO if we wanna access value on `ages[4]` we will access it `ages[4]` which will be `19`

![preview](https://i.imgur.com/CYbjPpj.png)
_Diagram from byju's_

> Notes: elements in array must have same datatype.

```c
int a = [1,4,7,3,6] // This is correct ✅
char b = ['d','a','s','g','h'] // This is also correct ✅
float c = [32,6.3,'d','a',42,'b'] // This is not allowed ❌
```

I hope this clears up what arrays means.

## Properties(Characteristics) of Array

- Array has number of memory cell which are called elements. each memory cell size occupy by which is depending on type of Array
- The array elements are always stored sequentially or linear form.
- Every elements has assigned a unique number which is called `"Address of particular element"`

## Types of array

There are three main types of array.

1. One Dimensional Array [1D Array]
2. Two Dimensional Array [2D Array]
3. Multi-Dimensional Array

## One Dimensional Array [1D Array]

### Syntax

```c
data_type arr_name[size];
```

### Example

```c
int ages[4] = [12,54,83,35]
```

```c
char vowels[5] = ['A','E','I','O','U']
```

## Two Dimensional Array [2D Array]

### Syntax

```c
data_type arr_name[row][column];
```

### Example

```c
int two_dimensional_arr[4][3];
```

### Initialization

```c
int arr[4][3]={{1,2,3},{2,3,4},{3,4,5},{4,5,6}};
```

## Array Practical Example

Example to find Row Major Order and Column Major Order in C.

```c
#include <stdio.h>
int Max = 10;

int main(){

  int arr[Max][Max], m, n, i, j;
  printf("\n Enter total number of row: ");
  scanf("%d", &m);
  printf("\n Enter total number of column: ");
  scanf("%d", &n);

  for(i=0;i<m;i++){
    for(j=0;j<n;j++){
      printf("\n Enter any number for array elements: ");
      scanf("%d", &arr[i][j]);
    }
  }

  printf("\n\nRow-Major Order:\n\n");

  for(i=0; i<m; i++){
    for(j=0; j<n; j++){
      printf("%d\t", arr[i][j]);
    }
    printf("\n");
  }

  printf("\n\nColumn-Major Order:\n\n");
  for(i=0; i<m; i++){
    for(j=0; j<n; j++){
      printf("%d\t", arr[j][i]);
    }
    printf("\n");
  }
}
```

### Output

![output](https://i.imgur.com/C78mFcp.png)
]]></description>
        </item>
        <item>
            <title><![CDATA[Basics Data Structure & Algorithm - Lecture 8]]></title>
            <link>https://dracodemy.vercel.app/posts/basics-data-structure-algorithm---lecture-8</link>
            <guid>https://dracodemy.vercel.app/posts/basics-data-structure-algorithm---lecture-8</guid>
            <pubDate>Wed, 13 Sep 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[
## Arrays Operations

Let's talk about operations that can be done on array in Data Structure.

## Traversing

- Accessing each data element in such a way that all the data elements are processed one by one.

## Insertion

- Adding new data element in Array.

## Deletion

- removing data element from Array.

## Searching

- Finding location for specific data in Array.

## Sorting

- Arranging array data in some logical order

## Merging

- Combining two array elements into single array.

## Array Traversing Example

```c
  int a[10];
  int count = 0;
  int UB; // Value of this will be size of array.

  while(count <= UB){
    count += 1;
  }

```

## Array Insertion Example

![preview](https://i.imgur.com/ovCtcsT.png)
]]></description>
        </item>
        <item>
            <title><![CDATA[Basics Data Structure & Algorithm - Lecture 9]]></title>
            <link>https://dracodemy.vercel.app/posts/basics-data-structure-algorithm---lecture-9</link>
            <guid>https://dracodemy.vercel.app/posts/basics-data-structure-algorithm---lecture-9</guid>
            <pubDate>Sat, 16 Sep 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[
## Strings

- String is collection of characters.
- Strings are written in double quotation mark (" ").
- Each string will get NULL character (\0) at the end of it.
- Strings are basically One Dimensional Array of characters.

## String Syntax

```c
char str_name[str_size] = "str_content"
```

## String Example

```c
char [] = "Hello"; // you can leave str_size empty which will have no limit in str_content.
```

![preview](https://i.imgur.com/LPuCOjC.png)

- Strings can contain all types of characters.
  - A to Z
  - a to z
  - 0 to 9
  - @, #, $, %, ^, etc.

## Initialization of string

### size defined string

```c
char str[30] = "preetsuthar.me"
```

### no size defined string

```c
char str[] = "preetsuthar.me"
```

### defining as array with size

```c
char str[30] = {"p","r","e","e","t","\0"} // Null character at the end.
```

### defining string as pointer

```c
char *str = "hello"
```

## Reading strings

### Reading string using `scanf()`

- We use `scanf()` in C language to read any input from user.
- `scanf()` won't read anything after whitespace in input string.

```c
"hello world" // it will only read till hello.
```

```c
  char str[];
  scanf("%s", &s);
```

### Reading string using `getchar()`

- This will just read first character in string.

  ```c
  "Hello world" // it will only read 'h'.
  ```

  ```c
    char str[10];
    str = getchar()
  ```

### Reading string using `gets()`

- This will read entire string element with all the white spaces and all the new lines.

```c
    Hello
    This will
    Read this string
    Exactly
    As it is.
```

```c
char str[10];
gets(str);
```

## Operations on string

_detailed information will be covered in upcoming lectures_

- String Read.
- String Write.
- String Length Count.
- String Case Conversion.
  - Uppercase To Lowercase and vice a versa.
- String Concatenate.
- String Copy.
- String Comparing.
- Substring.
  - Getting specified value from any index in string,
- String Reverse.
- String Append.
- String insertion.
- String Deletion.
]]></description>
        </item>
        <item>
            <title><![CDATA[Important Topics of Object Oriented Programming]]></title>
            <link>https://dracodemy.vercel.app/posts/important-topics-of-object-oriented-programming</link>
            <guid>https://dracodemy.vercel.app/posts/important-topics-of-object-oriented-programming</guid>
            <pubDate>Wed, 27 Dec 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[
## Difference between POP and OOP

| POP                                                                          | OOP                                            |
| ---------------------------------------------------------------------------- | ---------------------------------------------- |
| Procedure Oriented Programming                                               | Object Oriented Programming                    |
| Top to bottom approach                                                       | Bottom to top approach                         |
| Divided into functions                                                       | Divided into classes and object                |
| Is slower than OOP                                                           | Is faster than POP                             |
| Doesn’t support polymorphism                                                 | Supports polymorphism                          |
| Doesn’t support advance functionality like data abstraction and inheritance. | Does support data abstraction and inheritance. |
| Code reusability isn’t supported                                             | Code can be reused multiple times              |
| ex: C, Pascal                                                                | ex: C++, Java                                  |

## Basic concepts of OOP

There are five basic concepts of OOP:

1. Class

   - It is collection of object.
   - it is passive entity

   ```cpp
   class cars{
    bmw;
    audi;
    tata;
   };

   // In this example cars is an class
   ```

2. Objects

   - It is instance of an class
   - It is active entity

   ```cpp
   class cars{
    bmw;
    audi;
    tata;
   };

   // In this example cars is an class and bmw, audi and tata are objects
   ```

3. Inheritance

   - It is function where child class can acquire properties of parent class.
   - Inheritance has multiple types:

     - Single level inheritance.
     - Multilevel inheritance.
     - Multiple inheritance.
     - Hybrid inheritance.
     - Hierarchical inheritance.

     ```cpp
     class Person{
      public:
       string name;
       int age;
      class Person1
       {
        Person p;
        p.name = "Rahul";
        p.age = 30
       }
     }

     // In above example Person is parent class and Person1 is child class
     // where child is acquiring properties from parent class.

     ```

4. Polymorphism
   - In this Poly means **\*\*\***“many”**\*\*\*** and Morphism means **“Forms”**
   - Polymorphism basically means that a single function can do action in many forms.
   - For example:
     - A men can be Father, Friend, Employee at the same according to the situation.
5. Data Abstraction
   - C++ supports data abstraction which basically hides the process happening in the background after running the code.
   - For example:
     - Cell phones, we call using them but we cannot see the background process that works behind making the call sharing receiving the signals and all.
6. Dynamic binding
   - Dynamic binding basically combines multiple functions and classes into single unit.
   - For example:
     - A medicine capsule, It has multiple types of medicines combined in single capsule.
7. Message Passing.
   - Message passing means when two objects communicate with each other and share messages it’s called “Message Passing”.

## Scope resolution operator

- This operator is used to target global variables in your program.
- When there are two variables with same name but one is global and another is local. we can use Scope resolution operator to target global variable and print the value of that global variable.
- We can use \***\*`::`\*\*** to target scope resolution operator.

```cpp
int a = 10; //global variable

int main(){
 int a = 9; //local variable
 cout<<::a;
 return 0
}

//output
10

/* The output is global variable because we used scope resolution operator,
/ Which targets the variable outside of main function */
```

## Call by reference and return by reference

Call by reference:

- In call by reference both the actual parameters refers to same memory location. So if any one parameter or value changes it will affect both the parameters.
- Here we pass addresses.

```cpp
int main(){
 int x = 10, y = 20;
 sum(&x, &y)
}

int sum(int *ptr1, int *ptr2){ // we use pointers here because we are working on memory level.
 *ptr1 = 20;
 *ptr2 = 10;
}

/* These & are called address of operators.
Using these means we are directly targetting the address of the operator.*/

```

Return by reference:

- Return by reference means any function which returns reference it’s return the reference of function. We can return any value and it can be manipulated outside.

```cpp
//Example:

int a = 10;

int &ref(){
 return a; // this variable must be global
}

int main(){
 ref()=9; // changing the value of function
 cout<<ref();
 return 0;
}

//Output:
/*
9
*/
```

## Inline function, Default argument

Inline function:

- Basically inline function is type of function, when used it reduces the compile time for program.

```cpp
inline sum(int a, int b){
 return a+b;
}
```

- Here we made an inline function named sum which just returns the sum of two variables.
- Now whenever someone calls this inline function `sum()` what it will do is just while compiling it will replace the function call `sum()` to the code we placed inside in this case it will replace `sum()` to `a+b` corresponding to variables.
- Soo inline functions are used to decrease the compiling time.
  - Use of inline functions is limited it can be only used when there isn’t any complex function creation. It cannot work for loops, complex process or anything else complex things. It can be only used for basic functionality like addition, multiplication or maybe printing anything in terminal etc.

Default Arguments:

- These are the arguments we provide while making a function by default.
- These are the arguments that we don’t need to define while calling the function.

```cpp
int sum(int a, int b = 10)
{
 return a+b;
}

int main(){
 sum(10);
}

```

## Types of Constructor mainly three types ( Default , parameterized , copy )

- There are three types of constructor:

  1. Default constructor.

     - A constructor that accepts no parameters is called default constructor.
     - Syntax

     ```cpp
     class_name(){
      // code
     }
     ```

  2. Parameterized constructor.

     - A constructor that accepts or receive parameters is called parameterized constructor.
     - Syntax

     ```cpp
     class_name(para1,para2,...)
     {
     //code
     }
     ```

     - Example:

     ```cpp
     #include <iostream>

     class A{
      private:
       int a,b;
      public:
       A(int x, int y){
        a=x;
        b=y;
       }
       void show(){
        cout<<a" "b;
       }
     };

     int main()
     {
      A obj(10,20);
      obj.show();
     }

     /* Output:
       10,20 */
     ```

  3. Copy constructor.

     - It is used to copy or initialize the value of one object into another object.
     - Syntax:

     ```cpp

     ```

## Inheritance

- Inheritance:
  - It is type of function where child class can acquire properties of the parent class.
- There are 5 types of inheritance,

  1. Single Inheritance

     - In single inheritance there are only two classes base class and derived class.
       ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/eaa8ded2-35a9-4a4d-845a-d98b5f86f4eb/Untitled.png)
     - Syntax:

       ```cpp
       class A{
       //code
       };
       class B:access_specifier A{
       //code
       }
       ```

     - Example:

       ```cpp
       #include <iostream>

       using namespace std;

       class A{
        public:
         void show_a(){
          cout<<"a";
         }
       };

       class B: public A{
           public:
            void show_b(){
             cout<<"b";
            }
       };

       int main(){
        B obj;
        obj.show_a();
        obj.show_b();
       }
       ```

  2. Multilevel Inheritance

     - When one class inherits another class and that class further inherits another class is called “multilevel inheritance”.
       ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/cb05b47c-2d0c-492b-ad3e-09e46aae3a4c/Untitled.png)
     - Syntax:

       ```cpp
       class A{
       //code
       };
       class B:access_specifier A{
       //code
       };
       class C:access_specifier B{
       //code
       };
       ```

     - Example:

     ```cpp
     #include <iostream>

     using namespace std;

     class A{
      public:
       void show_a(){
        cout<<"a";
       }
     };

     class B: public A{
         public:
          void show_b(){
           cout<<"b";
          }
     };

     class C: public B{
       public:
        void show_c(){
         cout<<"c";
        }
     };

     int main(){
      C obj;
      obj.show_a();
      obj.show_b();
      obj.show_c();
     }
     ```

  3. Multiple Inheritance

     - When single child class can acquire properties of multiple parent class is called “multilevel inheritance”
       ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5444fd1b-99a2-4ca5-8a5e-2ce33b95d449/Untitled.png)
     - Syntax:

       ```cpp
       class A{
       //code
       };
       class B{
       //code
       };
       class C{
       //code
       };
       class D:access_specifier A,access_specifier B,access_specifier C{
       //code
       };

       ```

     - Example:

     ```cpp
     #include <iostream>
     using namespace std;

     class A{
      public:
       void show_a(){
        cout<<"a";
       }
     };

     class B{
      public:
       void show_b(){
        cout<<"b";
      }
     };

     class C{
      public:
       void show_c(){
        cout<<"c";
      }
     };

     class child_class:public A, public B, public C{
      public:
       void show_out(){
        cout<<"Child Class exit";
       }
     };

     int main(){
      child_class obj;
      obj.show_a();
      obj.show_b();
      obj.show_c();
      obj.show_out();
      return 0;
     }
     ```

  4. Hierarchical Inheritance

     - When there are more than one child class which can acquire properties of single parent class is called “Hierarchical inheritance”.

     ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/50cd2792-4650-4709-9c08-f7c1729c9b28/Untitled.png)

     - Syntax:

       ```cpp
       class A{
       //code
       };
       class B:access_specifier A{
       //code
       };
       class C:access_specifier A{
       //code
       };
       ```

     - Example:

       ```cpp
       #include <iostream>
       using namespace std;

       class A{
        public:
         void show_a(){
          cout<<"a";
         }
       };

       class B:public A{
        public:
         void show_b(){
          cout<<"b";
         }
       };

       class C:public A{
        public:
         void show_c(){
          cout<<"c";
         }
       };

       int main(){
        C obj;
        obj.show_a();
        obj.show_c();
        B obj2;
        obj2.show_a();
        obj2.show_b();
        return 0;
       }
       ```

  5. Hybrid Inheritance.

     - Hybrid inheritance is combination of more than one inheritance.

     ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/03c99623-c3d0-4d24-9726-20e0c83cd4c6/Untitled.png)

     - Syntax:

     ```cpp
     class A{
     //code
     };

     class B:public A{
     //code
     };

     class C:public A{
     //code
     };

     class D:public B, public C{
     //code
     };
     ```

     - Example:

       ```cpp
       #include <iostream>
       using namespace std;

       class A{
        public:
         void show_a(){
          cout<<"a";
         }
       };

       class B:public A{
        public:
         void show_b(){
          cout<<"b";
         }
       };

       class C:public A{
        public:
         void show_c(){
          cout<<"c";
         }
       };

       class D:public B, public C{
           public:
               void show_d(){
                   cout<<"d";
               }

       };

       int main(){
        B obj;
        obj.show_a();
        obj.show_b();
        D obj2;
        obj2.show_b();
        obj2.show_c();
        return 0;
       }
       ```

## Pointer ( this pointer)

- In CPP this pointer hold address of current object
- This is keyword in CPP which is used to define this pointer.

```cpp
int main(){
 cname obj;
 obj.add(); //this pointer holds the address of obj
}
```

- How to access member using `this pointer`?

```cpp
m = 10
this -> m = 10;
(*this).m = 10;

// All these three are same statement and last both are this pointer statement and all these statements means m = 10;
```

- Example:

  ```cpp
  #include <iostream>

  using namespace std;

  class mobile{
      int m = 10;
      public:
          void display(){
              cout<<"m = "<<m;
              cout<<"this -> m = "<<this -> m ;
              cout<<"(*this).m ="<<(*this).m;
          }
  };

  int main(){
      mobile obj;
      obj.display();
      return 0;
  }

  /* OUTPUT:
  m=10
  this -> m=10
  (*this).m=10

  */
  ```
]]></description>
        </item>
        <item>
            <title><![CDATA[Must know Topics of Object Oriented Programming]]></title>
            <link>https://dracodemy.vercel.app/posts/must-know-topics-of-object-oriented-programming</link>
            <guid>https://dracodemy.vercel.app/posts/must-know-topics-of-object-oriented-programming</guid>
            <pubDate>Sat, 06 Jan 2024 00:00:00 GMT</pubDate>
            <description><![CDATA[
## Difference between POP and OOP

| POP                                                                          | OOP                                            |
| ---------------------------------------------------------------------------- | ---------------------------------------------- |
| Procedure Oriented Programming                                               | Object Oriented Programming                    |
| Top to bottom approach                                                       | Bottom to top approach                         |
| Divided into functions                                                       | Divided into classes and object                |
| Is slower than OOP                                                           | Is faster than POP                             |
| Doesn’t support polymorphism                                                 | Supports polymorphism                          |
| Doesn’t support advance functionality like data abstraction and inheritance. | Does support data abstraction and inheritance. |
| Code reusability isn’t supported                                             | Code can be reused multiple times              |
| ex: C, Pascal                                                                | ex: C++, Java                                  |

## Basic concepts of OOP

There are five basic concepts of OOP:

1. Class

   - It is collection of object.
   - it is passive entity

   ```cpp
   class cars{
    bmw;
    audi;
    tata;
   };

   // In this example cars is an class
   ```

2. Objects

   - It is instance of an class
   - It is active entity

   ```cpp
   class cars{
    bmw;
    audi;
    tata;
   };

   // In this example cars is an class and bmw, audi and tata are objects
   ```

3. Inheritance

   - It is function where child class can acquire properties of parent class.
   - Inheritance has multiple types:

     - Single level inheritance.
     - Multilevel inheritance.
     - Multiple inheritance.
     - Hybrid inheritance.
     - Hierarchical inheritance.

     ```cpp
     class Person{
      public:
       string name;
       int age;
      class Person1
       {
        Person p;
        p.name = "Rahul";
        p.age = 30
       }
     }

     // In above example Person is parent class and Person1 is child class
     // where child is acquiring properties from parent class.

     ```

4. Polymorphism
   - In this Poly means **\*\*\***“many”**\*\*\*** and Morphism means **“Forms”**
   - Polymorphism basically means that a single function can do action in many forms.
   - For example:
     - A men can be Father, Friend, Employee at the same according to the situation.
5. Data Abstraction
   - C++ supports data abstraction which basically hides the process happening in the background after running the code.
   - For example:
     - Cell phones, we call using them but we cannot see the background process that works behind making the call sharing receiving the signals and all.
6. Dynamic binding
   - Dynamic binding basically combines multiple functions and classes into single unit.
   - For example:
     - A medicine capsule, It has multiple types of medicines combined in single capsule.
7. Message Passing.
   - Message passing means when two objects communicate with each other and share messages it’s called “Message Passing”.

## Advantages and application of OOP

- There are so many advantages of OOP here are few of them,
  - Code reusability:
    - OOP code is something which can reused in any other OOP program that program will run and compile successfully\*.
  - OOP functions:
    - OOP supports advances processes and functions like Data hiding, Dynamic binding, Polymorphism, Inheritance
  - Troubleshooting:
    - Because OOP is divided into classes and objects it’s easier to troubleshoot the code.
  - Security:
    - OOP has better security function for data or variables in code.

## Structure of C++ Program

- Here is the basic structure for mostly any C++ program

```cpp
#include <iostream>
using namespace std;

int main()
{
 int a = 10;
 cout<<a;
 return 0;
}
```

- Header files:
  - `#include <iostream>`
  - This is a header file which is used to include external functions in program. There are so many of these header files we can use any according to our need.
- Main function:
  - `int main(){
// Code
}`
  - This is main function where all the code should be written or defined. Our program can’t run without main function.
- Variables:
  - `int a = 10;`
  - This is a variable which basically stores value for something in something.
  - In this example we have stored 10 as value in variable named a.
- Input/Output files:
  - `cout<<a`
  - To print any output in console we can use `cout<<` or to take any input from user we can use `cin>>`
  - In this example we are using output so we used `cout<<a` and just like that we’re printing value of a.
- Return 0:
  - `return 0`
  - We used return statement and this is used to return any information or variables from function.
  - We cannot use this statement in any void functions.
  - If we’re using `int main()` we are required to return something if nothing then return 0;

## Basic data types

- There are three types of datatypes:
  1. Primitive datatypes.
     - These are the types of datatypes which are default included in c++
       - int
       - boolean
       - float
       - string
       - character
  2. Derived datatypes.
     - These are the types of datatypes which are derived from primitive or built from primitive datatypes.
       - Functions
       - Arrays
       - Pointers
  3. User-defined datatypes.
     - These are custom datatypes which are defined by a particular user.
       - Class
       - Structure
       - Union

## User defined data types and derived data types

- Derived datatypes:

  1. Functions

     - These are the type of datatypes which are used when our program is big and we need to make it easier so we divide it into multiple blocks which are called functions and than we can define those functions and call them into main function.

     ```cpp

     int sum(); //declaration

     int main()
     {
      a = sum(x,y); //calling function
      return 0;
     }

     int sum(int a, int b){ //defining function
      return a+b;
     }
     ```

  2. Arrays

  - Array is just collection of similar types of datatypes. we use arrays when we need to define multiple amount of variable with same datatype.

  ```cpp
  int arr[] = {10,20,30,40,50} // here we defined 5 variables with same datatype int.
  ```

  1. Constant

     - Constant is a keyword which is used to make variable constant which means value of variable doesn’t change while or after or before compiling the program. the value of constant remains same.

     ```cpp
     const int a = 39; // the value of int a cannot be changed dynamically
     ```

  2. Pointers

     - Pointers are just another datatypes which are used to target the memory location of particular variable
     - using pointers we can directly work on memory level for variables.

     ```cpp
     int a = 10;
     int *ptr;
     ptr = &a;
     ```

- User defined datatypes:

  1. Class

     - Class is collection of multiple objects.
     - It represent similar types of objects.

     ```cpp
     class student{
      string name; // objects
      int enroll_no; // objects
      int year; // objects
     };
     ```

  2. Structure

     - It is collection of different datatypes.

     ```cpp
     struct student{
      string name;
      int roll_no;
      int year;
     };
     ```

  3. Union

     - Union is similar to structure but it shares the same memory location of definition.

     ```cpp
     union share{
      int a;
      char ch;
     };

     Union share c;
     ```

## Reference variable

Reference variable:

- Basically reference variable means alias to existing variable.
- It gives another name to an existing variable.
- Which means both of the variables one existing and another reference will share same variable mean both are just single variable.
- Whenever value of variable will be changed it will make changes on both of the variable.
- We cannot give NULL value to reference variable.
- You cannot have reference to reference.
- They are easy.

```cpp
 int x = 1;
 int *pX = &x;
 *pX = 5 // x = 5
```

## Scope resolution operator

- This operator is used to target global variables in your program.
- When there are two variables with same name but one is global and another is local. we can use Scope resolution operator to target global variable and print the value of that global variable.
- We can use \***\*`::`\*\*** to target scope resolution operator.

```cpp
int a = 10; //global variable

int main(){
 int a = 9; //local variable
 cout<<::a;
 return 0
}

//output
10

/* The output is global variable because we used scope resolution operator,
/ Which targets the variable outside of main function */
```

## Call by reference and return by reference

Call by reference:

- In call by reference both the actual parameters refers to same memory location. So if any one parameter or value changes it will affect both the parameters.
- Here we pass addresses.

```cpp
int main(){
 int x = 10, y = 20;
 sum(&x, &y)
}

int sum(int *ptr1, int *ptr2){ // we use pointers here because we are working on memory level.
 *ptr1 = 20;
 *ptr2 = 10;
}

/* These & are called address of operators.
Using these means we are directly targetting the address of the operator.*/

```

Return by reference:

- Return by reference means any function which returns reference it’s return the reference of function. We can return any value and it can be manipulated outside.

```cpp
//Example:

int a = 10;

int &ref(){
 return a; // this variable must be global
}

int main(){
 ref()=9; // changing the value of function
 cout<<ref();
 return 0;
}

//Output:
/*
9
*/
```

## Inline function, Default argument

Inline function:

- Basically inline function is type of function, when used it reduces the compile time for program.

```cpp
inline sum(int a, int b){
 return a+b;
}
```

- Here we made an inline function named sum which just returns the sum of two variables.
- Now whenever someone calls this inline function `sum()` what it will do is just while compiling it will replace the function call `sum()` to the code we placed inside in this case it will replace `sum()` to `a+b` corresponding to variables.
- Soo inline functions are used to decrease the compiling time.
  - Use of inline functions is limited it can be only used when there isn’t any complex function creation. It cannot work for loops, complex process or anything else complex things. It can be only used for basic functionality like addition, multiplication or maybe printing anything in terminal etc.

Default Arguments:

- These are the arguments we provide while making a function by default.
- These are the arguments that we don’t need to define while calling the function.

```cpp
int sum(int a, int b = 10)
{
 return a+b;
}

int main(){
 sum(10);
}

```

## Function overloading and friend function

Function overloading:

- When any program has two or more functions with same name but with different types or parameters is called \***\*\*\*\***“Function Overloading”.\***\*\*\*\***
- There’s a catch that when there are two functions with same name they must have different parameters in them. two functions with same name cannot have same parameters.

```cpp
int sum(int a, int b){
 return a+b;
}

int sum(double a, double b){
 return a+b;
}

int main(){
 sum(10,10); /* Here because we gave integer parameters it will call the
function which has integer args. */
 sum(4.2,6.3); /* And here we gave point value double value it will call
 function which has double args. */
}

/* Output:
 20
 10.5
*/
```

Friend function:

- It is a type of function which can access value of private or protected without even being member of class.
- Friend function is declared in class with friend keyword.
- Friend function can become friend to more than one class.

Syntax:

```cpp
friend data_type name(){
//code
}
```

## Array

- Array is basically collection of similar types of datatypes.
- ex:
  `{1,2,3}` ✅ (This is valid array, all integers)
  `{’c’,’d’,’h’,’k’}` ✅ (This is valid array, all characters)
  `{234,6.3,’s,”hello”}` ❌ (This isn’t valid array cause there are multiple datatypes)
- Array index starts from 0.
  - `int arr[4] = {1,2,3,4}`
    - 0 index = 1
    - 1 index = 2
    - 2 index = 3
    - 3 index = 4

Syntax:

- `datatype arrayName[size];`

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/de64b779-33ed-4f9b-a390-d72007222cf7/Untitled.png)

## Characteristics of Constructor and Destructor

Constructor:

- It is special type of function which has same name as class.
- Constructor is called automatically when an object is created.
- Return type of constructor is same as class type.

Destructor:

- Destructor is used to deallocate the memory which was created by constructor.
- Destructor is special member function.
- It is executed automatically when an object is destroyed that has been created by constructor.
- Destructor declaration should always begin with tilde sign `~`

Example of constructor and destructor:

```cpp
#include <iostream.h>
#include <conio.h>

class test
{
 public:
  test(){
    cout<<"Constructor started";
  }
  ~test(){
    cout<<"Destructor started";
  }
};

int main(){
 test obj;
}
```

## Types of Constructor mainly three types ( Default , parameterized , copy )

- There are three types of constructor:

  1. Default constructor.

     - A constructor that accepts no parameters is called default constructor.
     - Syntax

     ```cpp
     class_name(){
      // code
     }
     ```

  2. Parameterized constructor.

     - A constructor that accepts or receive parameters is called parameterized constructor.
     - Syntax

     ```cpp
     class_name(para1,para2,...)
     {
     //code
     }
     ```

     - Example:

     ```cpp
     #include <iostream>

     class A{
      private:
       int a,b;
      public:
       A(int x, int y){
        a=x;
        b=y;
       }
       void show(){
        cout<<a" "b;
       }
     };

     int main()
     {
      A obj(10,20);
      obj.show();
     }

     /* Output:
       10,20 */
     ```

  3. Copy constructor.

     - It is used to copy or initialize the value of one object into another object.
     - Syntax:

     ```cpp
     class_name(class_name &var){
     //code
     }
     ```

     - Example:

     ```cpp
     #include <iostream>

     class A{
      private:
       int a,b;
      public:
       A(int x, int y){
        a=x;
        b=y;
       }
       A(A &ref){
        a = ref.a;
        b = ref.b;
       }

       void show(){
        cout<<a<<" "<<b;
       }
     };

     int main(){
       A obj(10,20);
       A obj2=obj;
       obj.show();
       obj2.show();
     }

     /* OUTPUT:
       10 20
       10 20
     */
     ```

## Definition of public private protected and ambiguity

- Public:
  - members can be accessed outside of the class
- Private:
  - Members cannot be accessed directly outside of the class we can use functions like friend function to access them.
- Protected:
  - Members cannot be accessed no matter what. they can be accessed in inherit class.
- Example:

  ```cpp
  class MyClass {
    public:    // Public access specifier
      int x;   // Public attribute
    private:   // Private access specifier
      int y;   // Private attribute
  };

  int main() {
    MyClass myObj;
    myObj.x = 25;  // Allowed (public)
    myObj.y = 50;  // Not allowed (private)
    return 0;
  }
  ```

## Inheritance and types of inheritance

- Inheritance:
  - It is type of function where child class can acquire properties of the parent class.
- There are 5 types of inheritance,

  1. Single Inheritance

     - In single inheritance there are only two classes base class and derived class.
       ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/eaa8ded2-35a9-4a4d-845a-d98b5f86f4eb/Untitled.png)
     - Syntax:

       ```cpp
       class A{
       //code
       };
       class B:access_specifier A{
       //code
       }
       ```

     - Example:

       ```cpp
       #include <iostream>

       using namespace std;

       class A{
        public:
         void show_a(){
          cout<<"a";
         }
       };

       class B: public A{
           public:
            void show_b(){
             cout<<"b";
            }
       };

       int main(){
        B obj;
        obj.show_a();
        obj.show_b();
       }
       ```

  2. Multilevel Inheritance

     - When one class inherits another class and that class further inherits another class is called “multilevel inheritance”.
       ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/cb05b47c-2d0c-492b-ad3e-09e46aae3a4c/Untitled.png)
     - Syntax:

       ```cpp
       class A{
       //code
       };
       class B:access_specifier A{
       //code
       };
       class C:access_specifier B{
       //code
       };
       ```

     - Example:

     ```cpp
     #include <iostream>

     using namespace std;

     class A{
      public:
       void show_a(){
        cout<<"a";
       }
     };

     class B: public A{
         public:
          void show_b(){
           cout<<"b";
          }
     };

     class C: public B{
       public:
        void show_c(){
         cout<<"c";
        }
     };

     int main(){
      C obj;
      obj.show_a();
      obj.show_b();
      obj.show_c();
     }
     ```

  3. Multiple Inheritance

     - When single child class can acquire properties of multiple parent class is called “multilevel inheritance”
       ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5444fd1b-99a2-4ca5-8a5e-2ce33b95d449/Untitled.png)
     - Syntax:

       ```cpp
       class A{
       //code
       };
       class B{
       //code
       };
       class C{
       //code
       };
       class D:access_specifier A,access_specifier B,access_specifier C{
       //code
       };

       ```

     - Example:

     ```cpp
     #include <iostream>
     using namespace std;

     class A{
      public:
       void show_a(){
        cout<<"a";
       }
     };

     class B{
      public:
       void show_b(){
        cout<<"b";
      }
     };

     class C{
      public:
       void show_c(){
        cout<<"c";
      }
     };

     class child_class:public A, public B, public C{
      public:
       void show_out(){
        cout<<"Child Class exit";
       }
     };

     int main(){
      child_class obj;
      obj.show_a();
      obj.show_b();
      obj.show_c();
      obj.show_out();
      return 0;
     }
     ```

  4. Hierarchical Inheritance

     - When there are more than one child class which can acquire properties of single parent class is called “Hierarchical inheritance”.

     ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/50cd2792-4650-4709-9c08-f7c1729c9b28/Untitled.png)

     - Syntax:

       ```cpp
       class A{
       //code
       };
       class B:access_specifier A{
       //code
       };
       class C:access_specifier A{
       //code
       };
       ```

     - Example:

       ```cpp
       #include <iostream>
       using namespace std;

       class A{
        public:
         void show_a(){
          cout<<"a";
         }
       };

       class B:public A{
        public:
         void show_b(){
          cout<<"b";
         }
       };

       class C:public A{
        public:
         void show_c(){
          cout<<"c";
         }
       };

       int main(){
        C obj;
        obj.show_a();
        obj.show_c();
        B obj2;
        obj2.show_a();
        obj2.show_b();
        return 0;
       }
       ```

  5. Hybrid Inheritance.

     - Hybrid inheritance is combination of more than one inheritance.

     ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/03c99623-c3d0-4d24-9726-20e0c83cd4c6/Untitled.png)

     - Syntax:

     ```cpp
     class A{
     //code
     };

     class B:public A{
     //code
     };

     class C:public A{
     //code
     };

     class D:public B, public C{
     //code
     };
     ```

     - Example:

       ```cpp
       #include <iostream>
       using namespace std;

       class A{
        public:
         void show_a(){
          cout<<"a";
         }
       };

       class B:public A{
        public:
         void show_b(){
          cout<<"b";
         }
       };

       class C:public A{
        public:
         void show_c(){
          cout<<"c";
         }
       };

       class D:public B, public C{
           public:
               void show_d(){
                   cout<<"d";
               }

       };

       int main(){
        B obj;
        obj.show_a();
        obj.show_b();
        D obj2;
        obj2.show_b();
        obj2.show_c();
        return 0;
       }
       ```

## Virtual base class

- Virtual base class is used to overcome issue of diamond problems. :) idk
  ![Here in this diagram if notice closely data of `Students` is inherited into `Exams` and also into `Projects`.  Data of `Exam` and `Projects` is being inherited into `Results`. So basically what we can say is the data from `Student`Is inherited twice into `Results` right? like `Results` got two copies of data from `Student`. So in this case while compiling, compiler confuses which data it should process on and at last it gives us an error. To avoid this sorta problem we use ******************************************************Virtual base class******************************************************.](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d3060760-d06b-483d-a1a6-632d89c480d3/Untitled.png)
  Here in this diagram if notice closely data of `Students` is inherited into `Exams` and also into `Projects`. Data of `Exam` and `Projects` is being inherited into `Results`. So basically what we can say is the data from `Student`Is inherited twice into `Results` right? like `Results` got two copies of data from `Student`. So in this case while compiling, compiler confuses which data it should process on and at last it gives us an error. To avoid this sorta problem we use \***\*\*\*\*\*\*\***\*\*\***\*\*\*\*\*\*\***\*\*\***\*\*\*\*\*\*\***\*\*\***\*\*\*\*\*\*\***Virtual base class\***\*\*\*\*\*\*\***\*\*\***\*\*\*\*\*\*\***\*\*\***\*\*\*\*\*\*\***\*\*\***\*\*\*\*\*\*\***.
- Syntax:

```cpp
class Student{
//code
};

class Exam:virtual public Student{
//code
};

class Project:virtual public Student{
//code
};

class Result: public Exam, public Project{
// only one copy of student data will be inherited
//code
};
```

## Pointer ( this pointer)

- In CPP this pointer hold address of current object
- This is keyword in CPP which is used to define this pointer.

```cpp
int main(){
 cname obj;
 obj.add(); //this pointer holds the address of obj
}
```

- How to access member using `this pointer`?

```cpp
m = 10
this -> m = 10;
(*this).m = 10;

// All these three are same statement and last both are this pointer statement and all these statements means m = 10;
```

- Example:

  ```cpp
  #include <iostream>

  using namespace std;

  class mobile{
      int m = 10;
      public:
          void display(){
              cout<<"m = "<<m;
              cout<<"this -> m = "<<this -> m ;
              cout<<"(*this).m ="<<(*this).m;
          }
  };

  int main(){
      mobile obj;
      obj.display();
      return 0;
  }

  /* OUTPUT:
  m=10
  this -> m=10
  (*this).m=10

  */
  ```

## Polymorphism

Polymorphism:

- Polymorphism word is made with two words poly which means many and morphism which means form. Same object with different behaviour.
- Basically polymorphism means many forms.
- When single function can work in many forms it is know as polymorphism.
- For example:
  - A men can be Father, Teacher, Friend at the same time. here Men is single thing but can work in many forms.
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0f6f99ed-aba0-4157-bc75-0c795bd2e2bc/Untitled.png)
- There are two types of polymorphism

  1. Compile time polymorphism

     - A compile time polymorphism is type of polymorphism which is worked in compile time.
     - It is also known as static polymorphism and early binding polymorphism
     - Example:

       - Method overloading.

       ```cpp
       void add (int x, int y){
       //code
       }
       void add (int x, float y){
       //code
       }
       ```

  2. Runtime polymorphism

     - A Polymorphism which is achieved by runtime is called “\***\*\*\*\***Runtime Polymorphism\***\*\*\*\***”.
     - It is also known as dynamic polymorphism
     - Example:

       - Method overriding.

       ```cpp
       void add () //base class
       {
       }
       voi add () //derived
       {
       }
       ```
]]></description>
        </item>
    </channel>
</rss>